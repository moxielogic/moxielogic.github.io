<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>The Moxie Blog - moxie</title><link href="http://moxielogic.github.io/blog/" rel="alternate"></link><link href="http://moxielogic.github.io/blog/feeds/moxie.atom.xml" rel="self"></link><id>http://moxielogic.github.io/blog/</id><updated>2016-03-02T00:00:00-05:00</updated><entry><title>Ledger launches moxie-based secure VM technology for blockchain applications</title><link href="http://moxielogic.github.io/blog/introducing-bolos.html" rel="alternate"></link><published>2016-03-02T00:00:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2016-03-02:/blog/introducing-bolos.html/</id><summary type="html">&lt;p&gt;So here's an interesting picture from &lt;a href="https://www.ledgerwallet.com"&gt;Ledger&lt;/a&gt;.  Check out the chewy center on the right -- that APP is a &lt;em&gt;moxie&lt;/em&gt; binary!&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bolos" src="https://cdn-images-2.medium.com/max/800/1*K5LiFrZiqHWMD2QkiioIcQ.png"&gt;
&lt;em&gt;Image credit: Ledger's &lt;a href="https://medium.com/@Ledger/introducing-bolos-blockchain-open-ledger-operating-system-b9893d09f333#.loy1hd3s3"&gt;blog&lt;/a&gt;&lt;/em&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.ledgerwallet.com"&gt;Ledger&lt;/a&gt;, the hardware bitcoin wallet company, just announced
&lt;a href="https://medium.com/@Ledger/introducing-bolos-blockchain-open-ledger-operating-system-b9893d09f333#.loy1hd3s3"&gt;BOLOS&lt;/a&gt;, the "Blockchain Open Ledger Operating Systems".  What's
most interesting to me, however, is that they have …&lt;/p&gt;</summary><category term="bitcoin"></category></entry><entry><title>Moxie Mixie: Frustrating Remote Attackers with Container Specific Instruction Sets</title><link href="http://moxielogic.github.io/blog/moxie-mixie.html" rel="alternate"></link><published>2016-01-14T00:00:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2016-01-14:/blog/moxie-mixie.html/</id><summary type="html">&lt;p&gt;While there are many existing technologies to frustrate remote
attackers, it can be fun to think up novel protections that might be
used to layer on additional defences.&lt;/p&gt;
&lt;p&gt;Consider, for instance, that remote code execution through attacks
like buffer overflows depends on knowledge of the remote systems'
instruction set.  Knowledge …&lt;/p&gt;</summary><category term="gcc"></category></entry><entry><title>Moxie talk at Bitcoin Dev Meetup</title><link href="http://moxielogic.github.io/blog/moxie-talk-at-bitcoin-dev-meetup.html" rel="alternate"></link><published>2015-02-15T15:21:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2015-02-15:/blog/moxie-talk-at-bitcoin-dev-meetup.html/</id><summary type="html">&lt;p&gt;&lt;center&gt;
&lt;img alt="" src="http://moxielogic.github.io/images/bcdev.jpeg"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;A very meta photo of me at the Toronto Bitcoin Developer Meetup
yesterday, explaining moxie, and the value of a security oriented VM
(moxiebox).&lt;/p&gt;
&lt;p&gt;Photo used by permission from Jan Miranda.&lt;/p&gt;</summary><category term="gcc"></category></entry><entry><title>An ELF Machine Number for Moxie</title><link href="http://moxielogic.github.io/blog/elf-machine-number.html" rel="alternate"></link><published>2015-01-09T15:21:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2015-01-09:/blog/elf-machine-number.html/</id><summary type="html">&lt;p&gt;Moxie was assigned an official ELF machine number this week!  You can
check it out here:
&lt;a href="http://www.sco.com/developers/gabi/latest/ch4.eheader.html"&gt;http://www.sco.com/developers/gabi/latest/ch4.eheader.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All ELF files start with a header describing properties of the object
at hand.  One of the most important properties is the 'machine' type …&lt;/p&gt;</summary><category term="gcc"></category></entry><entry><title>Compacting the code with shorter load/store offsets</title><link href="http://moxielogic.github.io/blog/shorter-load-store-offsets.html" rel="alternate"></link><published>2014-12-28T08:47:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-12-28:/blog/shorter-load-store-offsets.html/</id><summary type="html">&lt;p&gt;You may recall that moxie supports two instructions lengths: 16- and 48-bit.
Today I'm introducing a few 32-bit instructions as well.&lt;/p&gt;
&lt;p&gt;Previously, moxie's "load and store with offset" instructions were
defined as...&lt;/p&gt;
&lt;blockquote&gt;
&lt;table width='100%'&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;ldo.l&lt;/b&gt;&lt;/td&gt;&lt;td align='right'&gt;&lt;b&gt;00001100AAAABBBB iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
Load offset, long.  Loads into &lt;b&gt;$rA&lt;/b&gt; the 32-bit value from memory pointed at by …&lt;/blockquote&gt;</summary><category term="moxie"></category><category term="architecture"></category></entry><entry><title>Multiplication in the Real World</title><link href="http://moxielogic.github.io/blog/real-world-multiply.html" rel="alternate"></link><published>2014-12-24T08:47:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-12-24:/blog/real-world-multiply.html/</id><summary type="html">&lt;p&gt;The bitcoin team has been exercising moxie in ways that it hasn't been
stressed before.  For example, they've been examining the code quality
for their crypto libraries like
&lt;a href="https://github.com/bitcoin/secp256k1"&gt;libsecp256k1&lt;/a&gt;, an elliptical
curve crypto library in C.  One of their first feedbacks here was that
moxie provides no native way to …&lt;/p&gt;</summary><category term="moxie"></category><category term="gcc"></category><category term="architecture"></category></entry><entry><title>Moxiebox and bitcoin</title><link href="http://moxielogic.github.io/blog/moxiebox-and-bitcoint.html" rel="alternate"></link><published>2014-12-18T05:00:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-12-18:/blog/moxiebox-and-bitcoint.html/</id><summary type="html">&lt;p&gt;&lt;center&gt;
&lt;img alt="http://bitcoin.org" src="http://moxielogic.org/images/Bitcoin-logo.jpg"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;One of the more interesting developments around moxie is the adoption
of the &lt;a href="http://moxielogic.org/blog/pages/architecture.html"&gt;moxie
architecture&lt;/a&gt; by
the core bitcoin developers (&lt;a href="http://garzikrants.blogspot.ca/"&gt;Jeff
Garzik&lt;/a&gt;, in particular), for an
experimental project called
&lt;a href="http://github.com/jgarzik/moxiebox"&gt;&lt;code&gt;moxiebox&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To quote Jeff...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal is to provide a secure, sandboxed execution mechanism that enables deterministic input, processing and output …&lt;/p&gt;&lt;/blockquote&gt;</summary><category term="moxiebox"></category><category term="bitcoin"></category></entry><entry><title>Sign Extension</title><link href="http://moxielogic.github.io/blog/sign-extension.html" rel="alternate"></link><published>2014-04-04T00:40:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-04-04:/blog/sign-extension.html/</id><summary type="html">&lt;p&gt;Moxie zero-extends all 8 and 16-bit loads from memory. Until recently,
however, the GCC port didn't understand how loads worked, and would
always shift loaded values back and forth to either empty out the upper
bits or sign-extend the loaded value. While correct, it was overly
bloated. If we're loading …&lt;/p&gt;</summary></entry><entry><title>NetHack in your browser</title><link href="http://moxielogic.github.io/blog/nethack-in-your-browser.html" rel="alternate"></link><published>2014-01-26T18:12:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-01-26:/blog/nethack-in-your-browser.html/</id><summary type="html">&lt;p&gt;This is a moxie-rtems port of NetHack running on a modified version of
the gdb moxie simulator compiled to javascript with &lt;a href="https://github.com/kripken/emscripten" title="emscripten"&gt;emscripten&lt;/a&gt;.&lt;/p&gt;
&lt;canvas id="tty" class="screen" width="640" height="384"&gt;
                        Terminal uses canvas
                    &lt;/canvas&gt;

&lt;script src="http://kl7107.github.io/moxie-sim/c/terminal.js"&gt;&lt;/script&gt;

&lt;script src="http://kl7107.github.io/moxie-sim/c/terminal-input.js"&gt;&lt;/script&gt;

&lt;script src="http://kl7107.github.io/moxie-sim/c/moxie.js"&gt;&lt;/script&gt;

&lt;script src="http://kl7107.github.io/moxie-sim/c/nethack.js"&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href="http://github.com/kl7107"&gt;Krister Lagerström&lt;/a&gt; is responsible for this marvellous hack.&lt;/p&gt;
&lt;p&gt;Also, I suppose this blog entry represents a distribution of some GPL'd
source code from GDB, so …&lt;/p&gt;</summary><category term="gdb"></category><category term="NetHack"></category><category term="RTEMS"></category></entry><entry><title>The Moxie Game Console?</title><link href="http://moxielogic.github.io/blog/the-moxie-game-console.html" rel="alternate"></link><published>2014-01-11T06:06:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-01-11:/blog/the-moxie-game-console.html/</id><summary type="html">&lt;p&gt;Ok, not quite, but &lt;a href="https://github.com/kl7107" title="Krister"&gt;Krister Lagerström&lt;/a&gt; recently did something cool..&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="nethack" src="http://moxielogic.github.io/images/nethack.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;That's &lt;a href="http://www.nethack.org/" title="NetHack"&gt;NetHack&lt;/a&gt; ported to &lt;a href="http://rtems.org" title="RTEMS"&gt;RTEMS&lt;/a&gt; running on the moxie based &lt;a href="http://github.org/atgreen/moxie-cores" title="Marin SoC"&gt;Marin
SoC&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It runs on QEMU, via
"&lt;code&gt;qemu-system-moxie --nographic --machine marin --kernel nethack.elf&lt;/code&gt;",
or on FPGA hardware. I tested with a Nexys 3 Spartan-6 board by simply
converting it …&lt;/p&gt;</summary><category term="marin"></category><category term="NetHack"></category><category term="Nexys3"></category><category term="RTEMS"></category></entry><entry><title>Putting it together: on-chip firmware</title><link href="http://moxielogic.github.io/blog/putting-it-together-on-chip-firmware.html" rel="alternate"></link><published>2013-12-10T03:45:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-12-10:/blog/putting-it-together-on-chip-firmware.html/</id><summary type="html">&lt;p&gt;The on-chip &lt;a href="https://github.com/atgreen/moxie-cores/blob/master/firmware/bootrom/tinystub.c" title="firmware"&gt;firmware&lt;/a&gt; for the &lt;a href="https://github.com/atgreen/moxie-cores/tree/master/soc/marin" title="Marin SoC"&gt;Marin SoC&lt;/a&gt; has been updated with the
gdb stub, so now when you program the FPGA, you'll see the following on
the serial console:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MOXIE On-Chip Bootloader v2.0
Copyright (c) 2013 Anthony Green

Waiting for an S-Record Download or Remote GDB Connection...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...and the …&lt;/p&gt;</summary><category term="gdb"></category><category term="marin"></category><category term="Nexys3"></category><category term="r"></category></entry><entry><title>A Really Tiny GDB Remote Protocol Stub</title><link href="http://moxielogic.github.io/blog/a-really-tiny-gdb-remote-protocol-stub.html" rel="alternate"></link><published>2013-11-28T18:44:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-11-28:/blog/a-really-tiny-gdb-remote-protocol-stub.html/</id><summary type="html">&lt;p&gt;I recently trimmed the Marin SoC's on-chip memory down to 4k. The
existing firmware for downloading srecord programs into external RAM for
execution was taking up about 2k. With 2k to spare, I was wondering if
you could fit a GDB remote protocol stub in there as well. It turns …&lt;/p&gt;</summary><category term="gdb"></category><category term="marin"></category></entry><entry><title>Moxie on Altera's Cyclone II, and a Chance Encounter</title><link href="http://moxielogic.github.io/blog/moxie-on-alteras-cyclone-ii-and-a-chance-encounter.html" rel="alternate"></link><published>2013-08-08T18:59:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-08-08:/blog/moxie-on-alteras-cyclone-ii-and-a-chance-encounter.html/</id><summary type="html">&lt;p&gt;I recently fired up the Altera software, Quartus II, and spent a little
time porting the Marin SoC to the popular Cyclone II based DE2 board.
There's no external memory support yet, but on-chip memory is working,
and it looks like the on-chip bootloader is coming up properly. As
usual …&lt;/p&gt;</summary><category term="Altera"></category><category term="de2"></category><category term="marin"></category><category term="qemu"></category><category term="Quartus"></category></entry><entry><title>QEMU 1.5 includes Moxie support</title><link href="http://moxielogic.github.io/blog/qemu-1-5-includes-moxie-support.html" rel="alternate"></link><published>2013-05-21T04:16:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-05-21:/blog/qemu-1-5-includes-moxie-support.html/</id><summary type="html">&lt;p&gt;QEMU 1.5 was just released the other day, and in the &lt;a href="http://lists.nongnu.org/archive/html/qemu-devel/2013-05/msg02557.html"&gt;"And much
more..."&lt;/a&gt; category I'm happy to say that it includes Moxie support!&lt;/p&gt;
&lt;p&gt;This release contains basic Moxie core support, with the imaginary
"moxiesim" board support. I have some local changes that provide Marin
SoC emulation, and can …&lt;/p&gt;</summary><category term="marin"></category><category term="qemu"></category><category term="u-boot"></category></entry><entry><title>An On-Chip Bootloader</title><link href="http://moxielogic.github.io/blog/an-on-chip-bootloader.html" rel="alternate"></link><published>2013-05-06T02:25:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-05-06:/blog/an-on-chip-bootloader.html/</id><summary type="html">&lt;p&gt;Good news: we can access external memory! The logic for my pseudo-static
RAM controller is working, and big programs can finally run on hardware.&lt;/p&gt;
&lt;p&gt;You may recall that I had previously only been accessing fake memory
that was configured directly out of limited FPGA resources. I could
squeeze a tiny …&lt;/p&gt;</summary><category term="marin"></category><category term="newlib"></category><category term="u-boot"></category></entry><entry><title>And time ticks on...</title><link href="http://moxielogic.github.io/blog/and-time-ticks-on.html" rel="alternate"></link><published>2013-03-29T20:12:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-03-29:/blog/and-time-ticks-on.html/</id><summary type="html">&lt;p&gt;The interrupt controller &lt;a href="https://github.com/atgreen/moxie-cores/commit/0e44d0f29a2f05ef7f99fb1fc5d670d7f99d7c0b"&gt;is working now&lt;/a&gt;, as is the timer and my
exception handling firmware. So now I'm able to write a basic stop-watch
application, where the 7-segment display simply increments the count
every second. Yes, this sounds basic, but there's a lot of complexity
under the hood! This is …&lt;/p&gt;</summary><category term="marin"></category><category term="MoxieLite"></category><category term="qemu"></category><category term="RTEMS"></category><category term="SoC"></category></entry><entry><title>Moxie ports and hardware developments</title><link href="http://moxielogic.github.io/blog/moxie-ports-and-hardware-developments.html" rel="alternate"></link><published>2013-03-24T04:25:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-03-24:/blog/moxie-ports-and-hardware-developments.html/</id><summary type="html">&lt;p&gt;It's been a while since my last update.. let me bring you up to speed.&lt;/p&gt;
&lt;p&gt;A couple of &lt;a href="http://sourceware.org/libffi" title="libffi"&gt;libffi&lt;/a&gt; releases got in the way of moxie hacking
(although libffi 3.0.13 now includes full moxie support!), but things
are picking up speed again.&lt;/p&gt;
&lt;p&gt;On the software side of things …&lt;/p&gt;</summary><category term="binutils"></category><category term="FreeRTOS"></category><category term="gcc"></category><category term="marin"></category><category term="MoxieLite"></category><category term="newlib"></category><category term="Nexys3"></category><category term="RTEMS"></category></entry><entry><title>Native On-Chip GDB Remote Protocol Support</title><link href="http://moxielogic.github.io/blog/native-on-chip-gdb-remote-protocol-support.html" rel="alternate"></link><published>2012-11-24T05:47:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-11-24:/blog/native-on-chip-gdb-remote-protocol-support.html/</id><summary type="html">&lt;p&gt;A typical software debug solution for an embedded systems might involve
a &lt;a href="http://en.wikipedia.org/wiki/Joint_Test_Action_Group"&gt;JTAG&lt;/a&gt; connection to the board, and then some kind of protocol
translation software that handles communication between GDB's remote
serial protocol and the target JTAG port (see &lt;a href="http://openocd.sourceforge.net/"&gt;OpenOCD&lt;/a&gt;, for
instance). The FPGA systems I'm working with include JTAG …&lt;/p&gt;</summary><category term="gdb"></category><category term="JTAG"></category><category term="marin"></category><category term="SoC"></category></entry><entry><title>Running a C Program on the Marin SoC</title><link href="http://moxielogic.github.io/blog/running-a-c-program-on-the-marin-soc.html" rel="alternate"></link><published>2012-11-15T21:10:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-11-15:/blog/running-a-c-program-on-the-marin-soc.html/</id><summary type="html">&lt;p&gt;I've just committed the bits required to run a &lt;a href="https://github.com/atgreen/moxie-cores/blob/master/firmware/mdata.c"&gt;C program&lt;/a&gt; on the
Marin SoC.&lt;/p&gt;
&lt;p&gt;Rather than hook up the Nexys3 external RAM module, I'm using extra
space on the FPGA itself for RAM. Most of the hard work was sorting out
the &lt;a href="https://github.com/atgreen/moxie-cores/blob/master/soc/marin/moxie-marin.ld"&gt;linker script&lt;/a&gt; magic required to generate an …&lt;/p&gt;</summary><category term="fpga"></category><category term="gcc"></category><category term="marin"></category><category term="newlib"></category><category term="Nexys3"></category><category term="SoC"></category></entry><entry><title>Moxie SoC Progress</title><link href="http://moxielogic.github.io/blog/moxie-soc-progress.html" rel="alternate"></link><published>2012-11-10T05:23:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-11-10:/blog/moxie-soc-progress.html/</id><summary type="html">&lt;p&gt;Time for a quick update!&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;iframe width="560" height="315" src="http://www.youtube.com/embed/86-OkQcXEes" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;"Marin" is the name of my test SoC consisting of a &lt;a href="http://en.wikipedia.org/wiki/Wishbone_(computer_bus)" title="wishbone"&gt;wishbone&lt;/a&gt; wrapped
75Mhz big-endian MoxieLite bus master, along with two slave devices:
embedded ROM and the Nexys3's 7-segment display. So, right now I can
write some code into FPGA embedded ROM to manipulate the …&lt;/p&gt;</summary><category term="fpga"></category><category term="marin"></category><category term="MoxieLite"></category><category term="Nexys3"></category><category term="SoC"></category><category term="u-boot"></category><category term="wishbone"></category><category term="Xilinx"></category></entry><entry><title>Moxie and Free Software EDA at FSOSS</title><link href="http://moxielogic.github.io/blog/moxie-and-free-software-eda-at-fsoss.html" rel="alternate"></link><published>2012-10-16T15:09:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-10-16:/blog/moxie-and-free-software-eda-at-fsoss.html/</id><summary type="html">&lt;p&gt;I'll be speaking at &lt;a href="http://fsoss.senecac.on.ca" title="FSOSS"&gt;FSOSS&lt;/a&gt; in Toronto next week on moxie and Free
Software EDA tools. Check it out here:
&lt;a href="http://fsoss.senecac.on.ca/2012/node/150"&gt;http://fsoss.senecac.on.ca/2012/node/150&lt;/a&gt;.&lt;/p&gt;</summary><category term="FSOSS"></category></entry><entry><title>MoxieLite in Action</title><link href="http://moxielogic.github.io/blog/moxielite-in-action.html" rel="alternate"></link><published>2012-09-22T04:40:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-09-22:/blog/moxielite-in-action.html/</id><summary type="html">&lt;p&gt;&lt;center&gt;
&lt;img alt="" src="http://moxielogic.org/images/MoxieLite-400.jpg" title="First MoxieLite Shot"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Brad Robinson just sent me this awesome shot of &lt;a href="https://github.com/toptensoftware/MoxieLite" title="MoxieLite"&gt;MoxieLite&lt;/a&gt; in action.
His Xilinx Spartan-6 FPGA based SoC features a moxie core handling VGA
video, keyboard and FAT-on-flash filesystem duties using custom firmware
written in C. This is all in support of a second z80-based core on the
same FPGA …&lt;/p&gt;</summary><category term="fpga"></category><category term="gcc"></category><category term="MoxieLite"></category><category term="vga"></category><category term="Xilinx"></category></entry><entry><title>It's Alive!</title><link href="http://moxielogic.github.io/blog/its-alive.html" rel="alternate"></link><published>2012-09-14T14:39:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-09-14:/blog/its-alive.html/</id><summary type="html">&lt;p&gt;There's a working hardware implementation of moxie in the wild!&lt;/p&gt;
&lt;p&gt;Intrepid hacker &lt;a href="https://twitter.com/toptensoftware" title="Brad Robinson"&gt;Brad Robinson&lt;/a&gt; created this moxie-compatible core as
a peripheral controller for his SoC. He had been using a simple 8-bit
core, but needed to address more memory than was possible with the 8-bit
part. Moxie is a nice …&lt;/p&gt;</summary><category term="architecture"></category><category term="fpga"></category><category term="gcc"></category><category term="gdb"></category><category term="Nexys3"></category><category term="SoC"></category><category term="VHDL"></category><category term="Xilinx"></category></entry><entry><title>The case against the [L]GPL for Semiconductor Core Licensing</title><link href="http://moxielogic.github.io/blog/the-case-against-the-lgpl-for-semiconductor-core-licensing.html" rel="alternate"></link><published>2012-09-09T19:35:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-09-09:/blog/the-case-against-the-lgpl-for-semiconductor-core-licensing.html/</id><summary type="html">&lt;p&gt;Eli Greenbaum wrote a terrific article for the Harvard Journal of Law &amp;amp;
Technology last fall called '&lt;a href="http://jolt.law.harvard.edu/articles/pdf/v25/25HarvJLTech131.pdf"&gt;Open Source Semiconductor Core
Licensing&lt;/a&gt;'. I'm using the GPL as a place-holder in my verilog source,
but I've always felt that the GPL/LGPL were inappropriate licenses for
digital logic. Eli's article makes clear …&lt;/p&gt;</summary><category term="copyright"></category><category term="legal"></category><category term="licensing"></category></entry><entry><title>vfork() for uClinux forces an architecture change</title><link href="http://moxielogic.github.io/blog/vfork-for-uclinux-forces-an-architecture-change.html" rel="alternate"></link><published>2012-09-03T07:35:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-09-03:/blog/vfork-for-uclinux-forces-an-architecture-change.html/</id><summary type="html">&lt;p&gt;Moxie uses a simple software interrupt instruction (&lt;code&gt;swi&lt;/code&gt;) to implement
system calls. The &lt;code&gt;swi&lt;/code&gt; instruction creates a call frame on the stack
and then jumps to a global exception handler routine. The exception
handler for moxie-uClinux switches to the kernel stack before jumping to
the relevant kernel routine. Returning from …&lt;/p&gt;</summary><category term="architecture"></category><category term="linux"></category></entry><entry><title>Forking bugs</title><link href="http://moxielogic.github.io/blog/forking-bugs.html" rel="alternate"></link><published>2012-08-15T20:59:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-08-15:/blog/forking-bugs.html/</id><summary type="html">&lt;p&gt;I found some time to look at the Linux kernel port again, and discovered
a bug in the forking code (the child process must return 0 after a
fork!). What we're looking at here is the start of userland, post kernel
boot, where busybox is trying to run an init …&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Multiported Registers, Microcode and Register Forwarding</title><link href="http://moxielogic.github.io/blog/multiported-registers-microcode-and-register-forwarding.html" rel="alternate"></link><published>2012-07-01T14:46:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-07-01:/blog/multiported-registers-microcode-and-register-forwarding.html/</id><summary type="html">&lt;p&gt;When I last wrote about tackling the 'pop' instruction I noted that I
needed the ability to write to multiple registers before retiring that
one instruction - something that would require extra instruction cycles
or loads more logic. I recently came across some work by Charles Eric
LaForest on &lt;a href="http://www.eecg.utoronto.ca/~laforest/multiport/index.html" title="Efficient Multi-Ported Memories for FPGAs"&gt;Efficient Multi-Ported …&lt;/a&gt;&lt;/p&gt;</summary><category term="muskoka"></category><category term="verilog"></category></entry><entry><title>Notes on a novel in-game CPU: the dcpu-16</title><link href="http://moxielogic.github.io/blog/notes-on-a-novel-in-game-cpu-the-dcpu-16.html" rel="alternate"></link><published>2012-04-09T07:35:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-04-09:/blog/notes-on-a-novel-in-game-cpu-the-dcpu-16.html/</id><summary type="html">&lt;p&gt;The hacker behind the &lt;a href="http://www.minecraft.net/"&gt;Minecraft&lt;/a&gt; phenomena, Notch, is working on his
&lt;a href="http://0x10c.com/"&gt;next game&lt;/a&gt;, most likely another hit. This one is interesting in that
it includes an in-game 16-bit processor called the dcpu-16. Details are
sparse, but it seems as though gamers will use this processor to control
spacecraft and play …&lt;/p&gt;</summary><category term="architecture"></category><category term="binutils"></category><category term="dcpu-16"></category><category term="gcc"></category><category term="gdb"></category></entry><entry><title>Using the Altera USB-Blaster on Fedora</title><link href="http://moxielogic.github.io/blog/using-the-altera-usb-blaster-on-fedora.html" rel="alternate"></link><published>2011-10-28T13:14:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-10-28:/blog/using-the-altera-usb-blaster-on-fedora.html/</id><summary type="html">&lt;p&gt;Altera's Quartus tools include some special software to download
bitstreams to their devices over USB (a DE-2 eval board, in my case).
They require some tricky work to set up properly on Fedora - my dev host
of choice. But you're in luck! I've packaged up an RPM that takes care …&lt;/p&gt;</summary><category term="Altera"></category><category term="de2"></category><category term="JTAG"></category><category term="Quartus"></category></entry><entry><title>Fake RAM, load/store and push</title><link href="http://moxielogic.github.io/blog/fake-ram-loadstore-and-push.html" rel="alternate"></link><published>2011-10-11T19:00:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-10-11:/blog/fake-ram-loadstore-and-push.html/</id><summary type="html">&lt;p&gt;Progress report time....&lt;/p&gt;
&lt;p&gt;I need RAM in order to implement/test most instructions. To that end,
I've implemented a fake data cache that is always accessed within a
single cycle during the WRITE pipeline stage. Eventually this will have
to be replaced with a real data cache that reads/writes …&lt;/p&gt;</summary><category term="muskoka"></category><category term="SoC"></category><category term="wishbone"></category></entry><entry><title>GTKWave Tip #2: Translate Filter Files</title><link href="http://moxielogic.github.io/blog/gtkwave-tip-2-translate-filter-files.html" rel="alternate"></link><published>2011-10-06T17:10:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-10-06:/blog/gtkwave-tip-2-translate-filter-files.html/</id><summary type="html">&lt;p&gt;Tip #1 was about using an external process to perform dynamic
translations of signal display values. GTKWave can also perform simple
static translations of data. In the example below, for instance, moxie's
execute unit is receiving a 4-bit signal identifying "register A"
(riA_i) for whatever operation is about to happen …&lt;/p&gt;</summary><category term="gtkwave"></category></entry><entry><title>GTKWave Tip #1</title><link href="http://moxielogic.github.io/blog/gtkwave-tip-1.html" rel="alternate"></link><published>2011-10-04T10:34:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-10-04:/blog/gtkwave-tip-1.html/</id><summary type="html">&lt;p&gt;GTKWave is a new tool for me, so I'll use this space to post useful tips
as I discover them.&lt;/p&gt;
&lt;p&gt;The first tip comes from Tony Bybell, author of &lt;a href="http://gtkwave.sourceforge.net" title="GTKWave"&gt;GTKWave&lt;/a&gt;, who pointed
me at some helpful functionality in a recent &lt;a href="http://moxielogic.org/blog/?p=511" title="blog comment"&gt;blog comment&lt;/a&gt;. You can
enhance GTKWave's waveform display by replacing …&lt;/p&gt;</summary><category term="gtkwave"></category><category term="lisp"></category></entry><entry><title>Branch delays</title><link href="http://moxielogic.github.io/blog/branch-delays.html" rel="alternate"></link><published>2011-09-28T07:13:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-09-28:/blog/branch-delays.html/</id><summary type="html">&lt;p&gt;I've coded up logic for more arithmetic instructions, register moves, as
well as direct and indirect jumps. For jumps, I simply pass a branch
signal from the execute stage back to the fetch stage, as well as the
computed target address. Here's some code that works now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.text&lt;/span&gt;
    &lt;span class="nf"&gt;xor&lt;/span&gt; &lt;span class="no"&gt;$r0 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><category term="architecture"></category><category term="gas"></category><category term="verilog"></category></entry><entry><title>A simulation milestone for the Muskoka SoC!</title><link href="http://moxielogic.github.io/blog/a-simulation-milestone-for-the-muskoka-soc.html" rel="alternate"></link><published>2011-09-27T19:47:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-09-27:/blog/a-simulation-milestone-for-the-muskoka-soc.html/</id><summary type="html">&lt;p&gt;A moxie-based SoC had it's first successful simulation run today....&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="gtkwave display of first code run" src="http://moxielogic.org/blog/wp-content/uploads/2011/09/gtkwave20110927-300x204.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Pretty exciting! So, here's what's happening...&lt;/p&gt;
&lt;p&gt;The SoC, code named "Muskoka", has three main components: the moxie
core, a wishbone switch and a ROM device. The switch was easy to
implement, as I just have a single bus master (moxie …&lt;/p&gt;</summary><category term="architecture"></category><category term="muskoka"></category><category term="SoC"></category><category term="verilog"></category><category term="wishbone"></category></entry><entry><title>RTEMS status update</title><link href="http://moxielogic.github.io/blog/rtems-status-update.html" rel="alternate"></link><published>2011-06-15T04:35:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-06-15:/blog/rtems-status-update.html/</id><summary type="html">&lt;p&gt;The &lt;a href="http://www.rtems.com"&gt;RTEMS&lt;/a&gt; port in &lt;a href="http://www.moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt; is looking pretty good right now.
Here's a test of the RTEMS network loopback device running on the moxie
gdb simulator.  The first two client connections fail in this test. 
It's supposed to fail in the first case, but I'm not sure about the
second …&lt;/p&gt;</summary><category term="RTEMS"></category></entry><entry><title>Bisecting GCC</title><link href="http://moxielogic.github.io/blog/bisecting-gcc.html" rel="alternate"></link><published>2011-06-06T07:23:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-06-06:/blog/bisecting-gcc.html/</id><summary type="html">&lt;p&gt;The thing about &lt;a href="http://gcc.gnu.org"&gt;GCC&lt;/a&gt; is that things break when you take your eye off
the ball. And this is what happened during my months long hiatus from
the moxie project. Somewhere between early March and today, the moxie
GCC port lost the ability to compile non-trivial code, notably libgcc.
Firing …&lt;/p&gt;</summary><category term="ec2"></category><category term="gcc"></category><category term="git"></category></entry><entry><title>On-chip communications</title><link href="http://moxielogic.github.io/blog/on-chip-communications.html" rel="alternate"></link><published>2010-10-06T04:37:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-10-06:/blog/on-chip-communications.html/</id><summary type="html">&lt;p&gt;I need to build real SoC infrastructure around my developing core in
order to test it on real hardware. For the most part, this means a
memory controller and IO devices. I've decided to implement a shared-bus
wishbone-style interconnect for these devices. &lt;a href="http://en.wikipedia.org/wiki/Wishbone_%28computer_bus%29"&gt;Wishbone&lt;/a&gt; is an open
source on chip bus …&lt;/p&gt;</summary><category term="architecture"></category><category term="SoC"></category><category term="wishbone"></category></entry><entry><title>Quartus II and the Cloud: Not There Yet...</title><link href="http://moxielogic.github.io/blog/quartus-ii-and-the-cloud-not-there-yet.html" rel="alternate"></link><published>2010-09-20T15:55:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-09-20:/blog/quartus-ii-and-the-cloud-not-there-yet.html/</id><summary type="html">&lt;p&gt;Altera's &lt;a href="http://www.altera.com/products/software/quartus-ii/web-edition/qts-we-index.html"&gt;Quartus II&lt;/a&gt; software is now running on my Fedora box, but I
was really hoping to load it into a grid of &lt;a href="http://aws.amazon.com/ec2/"&gt;Amazon EC2 instances&lt;/a&gt; so
I could batch out jobs for synthesis, place and route. Unfortunately the
free-beer Quartus software requires a license file that is generated
based …&lt;/p&gt;</summary><category term="Altera"></category><category term="cloud"></category></entry><entry><title>Pipeline hazards</title><link href="http://moxielogic.github.io/blog/pipeline-hazards.html" rel="alternate"></link><published>2010-09-10T13:25:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-09-10:/blog/pipeline-hazards.html/</id><summary type="html">&lt;p&gt;I've coded up a first go at four pipeline stages so far: &lt;a href="http://github.com/atgreen/moxiedev/blob/master/moxie/rtl/verilog/cpu_fetch.v"&gt;Fetch&lt;/a&gt;,
&lt;a href="http://github.com/atgreen/moxiedev/blob/master/moxie/rtl/verilog/cpu_decode.v"&gt;Decode&lt;/a&gt;, &lt;a href="http://github.com/atgreen/moxiedev/blob/master/moxie/rtl/verilog/cpu_execute.v"&gt;Execute&lt;/a&gt;, and Write. After the relative complexity of the
&lt;a href="http://moxielogic.org/blog/?p=444"&gt;Fetch implementation&lt;/a&gt;, the rest has been pretty straight forward, and
I've started running the first bit of compiled code through the pipline.
Here's that start of our …&lt;/p&gt;</summary><category term="architecture"></category><category term="verilog"></category></entry><entry><title>Fetching instructions</title><link href="http://moxielogic.github.io/blog/fetching-instructions.html" rel="alternate"></link><published>2010-09-07T13:56:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-09-07:/blog/fetching-instructions.html/</id><summary type="html">&lt;p&gt;Moxie requires some interesting instruction fetch logic.&lt;/p&gt;
&lt;p&gt;For my initial implementation I'm assuming a 32-bit path to instruction
memory. But moxie has both 16- and 48-bit instructions, so it's not like
simple RISC cores that can feed the pipeline on every cycle. My solution
is to feed 32-bit instruction memory …&lt;/p&gt;</summary><category term="architecture"></category><category term="verilog"></category></entry><entry><title>The FPGA test board</title><link href="http://moxielogic.github.io/blog/the-fpga-test-board.html" rel="alternate"></link><published>2010-08-18T14:03:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-08-18:/blog/the-fpga-test-board.html/</id><summary type="html">&lt;p&gt;I picked up a lightly used FPGA development board from craigslist today.
It's the &lt;a href="http://www.altera.com/education/univ/materials/boards/unv-de2-board.html"&gt;Altera DE2&lt;/a&gt; board with a Cyclone II FPGA.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="&amp;quot;The DE2\'s Cyclone II &amp;quot;" src="http://moxielogic.org/blog/wp-content/uploads/2010/08/P1230549-300x225.jpg"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;There are a few nice things about this board...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It's loaded with real and useful peripherals: 16x2 LCD Panel, VGA
    DAC, lots of LEDs, RS232, IrDA, PS/2 …&lt;/li&gt;&lt;/ul&gt;</summary><category term="de2"></category><category term="fpga"></category></entry><entry><title>Still hacking...</title><link href="http://moxielogic.github.io/blog/still-hacking.html" rel="alternate"></link><published>2010-05-11T06:45:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-05-11:/blog/still-hacking.html/</id><summary type="html">&lt;p&gt;...Just in case you were wondering!&lt;/p&gt;
&lt;p&gt;But it's been slow going. The good news is that moxie is front and
centre for me again, so let's see what we can do over the next few
weeks. And over these next few weeks I'm promising myself not to touch a
C …&lt;/p&gt;</summary></entry><entry><title>The Moxielyzer</title><link href="http://moxielogic.github.io/blog/the-moxielyzer.html" rel="alternate"></link><published>2009-10-14T22:05:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-10-14:/blog/the-moxielyzer.html/</id><summary type="html">&lt;p&gt;I just committed a little binary analysis tool to &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt;. You can
use it to perform simple static analysis on moxie binaries. The kinds of
things I'm looking for are compiler bugs (because I know there's still
one there that is triggered by -frerun-cse-after-loop), and instruction
statistics. For instance, which …&lt;/p&gt;</summary><category term="architecture"></category><category term="moxielyzer"></category></entry><entry><title>Summer is over, so put away the white pants and start submitting patches!</title><link href="http://moxielogic.github.io/blog/summer-is-over-so-put-away-the-white-pants-and-start-submitting-patches.html" rel="alternate"></link><published>2009-09-10T14:21:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-09-10:/blog/summer-is-over-so-put-away-the-white-pants-and-start-submitting-patches.html/</id><summary type="html">&lt;p&gt;It's been a while since my last update. What can I say... summer was
nice.&lt;/p&gt;
&lt;p&gt;But now, back to business! I've just committed some long overdue patches
to the upstream GNU tools:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://sourceware.org/ml/gdb-patches/2009-09/msg00289.html"&gt;Add a device tree blob to the gdb simulator&lt;/a&gt;. This lets us
    describe the gdb sim target to …&lt;/li&gt;&lt;/ul&gt;</summary><category term="gcc"></category><category term="gdb"></category><category term="linux"></category><category term="qemu"></category><category term="verilog"></category></entry><entry><title>More hello world progress with uClibc/uClinux, and a GDB question.</title><link href="http://moxielogic.github.io/blog/more-hello-world-progress-with-uclibcuclinux-and-a-gdb-question.html" rel="alternate"></link><published>2009-08-18T21:49:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-08-18:/blog/more-hello-world-progress-with-uclibcuclinux-and-a-gdb-question.html/</id><summary type="html">&lt;p&gt;Tonight I got a hello world app to use uClibc's &lt;code&gt;puts()&lt;/code&gt; routine! This
is a big deal because it's the first time I've had system calls coming
in from userland. I haven't checked the changes in yet, because they're
a mess, but here's a basic run-down of what I had …&lt;/p&gt;</summary><category term="gdb"></category><category term="linux"></category></entry><entry><title>First moxie-linux userland app runs!</title><link href="http://moxielogic.github.io/blog/first-moxie-linux-userland-app-runs.html" rel="alternate"></link><published>2009-08-17T20:11:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-08-17:/blog/first-moxie-linux-userland-app-runs.html/</id><summary type="html">&lt;p&gt;I've been taking advantage of the nice summer weather recently, so it's
taken me a while to get around to this... but here's the first moxie
userland app!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#define MSG &amp;quot;Hello, World!\n&amp;quot;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;noinline&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;gloss_write&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;asm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;swi 5&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;write …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category></entry><entry><title>Speed bumps on the road to moxie userland</title><link href="http://moxielogic.github.io/blog/speed-bumps-on-the-road-to-moxie-userland.html" rel="alternate"></link><published>2009-07-30T13:46:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-30:/blog/speed-bumps-on-the-road-to-moxie-userland.html/</id><summary type="html">&lt;p&gt;Sooo..... it turns out there's lots to take care of before userland apps
like BusyBox can run.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The root filesystem&lt;/strong&gt;. This one is easy. I just built a short
    Hello World application in C with moxie-uclinux-gcc. This produces
    an executable in &lt;a href="http://www.beyondlogic.org/uClinux/bflt.htm"&gt;BFLT format&lt;/a&gt; which I call 'init'. The kernel
    build …&lt;/li&gt;&lt;/ul&gt;</summary><category term="architecture"></category><category term="gcc"></category><category term="linux"></category></entry><entry><title>The start of a uClinux userland</title><link href="http://moxielogic.github.io/blog/the-start-of-a-uclinux-userland.html" rel="alternate"></link><published>2009-07-28T15:24:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-28:/blog/the-start-of-a-uclinux-userland.html/</id><summary type="html">&lt;p&gt;Before we can start building &lt;a href="http://www.busybox.net"&gt;BusyBox&lt;/a&gt;, we need a few more bits of
technology...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.uclibc.org"&gt;uClibc&lt;/a&gt;: this is a popular embedded C library, like newlib, but
    used more often in Linux environments. I ported uClibc to the moxie
    core just like every other bit of software in this project: quickly!
    My …&lt;/li&gt;&lt;/ul&gt;</summary><category term="linux"></category></entry><entry><title>The first moxie linux boot output...</title><link href="http://moxielogic.github.io/blog/the-first-moxie-linux-boot-output.html" rel="alternate"></link><published>2009-07-26T12:43:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-26:/blog/the-first-moxie-linux-boot-output.html/</id><summary type="html">&lt;p&gt;Userland, here I come! Check out &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt;, run "ant build", then do
the following...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ./root/usr/bin/moxie-elf-run linux-2.6/vmlinux
Linux version &lt;span class="m"&gt;2&lt;/span&gt;.6.31-rc3-gb006656-dirty &lt;span class="o"&gt;(&lt;/span&gt;green@dev.moxielogic.com&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;gcc version &lt;span class="m"&gt;4&lt;/span&gt;.5.0 &lt;span class="m"&gt;20090715&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;experimental&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;trunk revision &lt;span class="m"&gt;149693&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;GCC&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#6 Sun Jul 26 12:03:14 EDT 2009 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category></entry><entry><title>Kernel update: device trees and kernel threads</title><link href="http://moxielogic.github.io/blog/kernel-update-device-trees-and-kernel-threads.html" rel="alternate"></link><published>2009-07-25T04:50:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-25:/blog/kernel-update-device-trees-and-kernel-threads.html/</id><summary type="html">&lt;p&gt;I've spent a lot of time in airports/planes/hotels recently, which is
good news for the moxie linux port. It runs about 6.5M instructions,
booting up to the point where a couple of kernel threads are created.
However, a few context switches later it all comes tumbling down …&lt;/p&gt;</summary><category term="gdb"></category><category term="linux"></category><category term="qemu"></category></entry><entry><title>The Moxie Linux port</title><link href="http://moxielogic.github.io/blog/the-moxie-linux-port.html" rel="alternate"></link><published>2009-07-23T03:50:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-23:/blog/the-moxie-linux-port.html/</id><summary type="html">&lt;p&gt;I've just checked the start of the kernel port into &lt;a href="http://www.moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt;.
Running "ant build" will produce tools, simulators, u-boot and now a
vmlinux you can run with moxie-elf-run or in gdb. It crashes on startup
right now, but that's to be expected. I just got it to the point where …&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Reverse debugging!</title><link href="http://moxielogic.github.io/blog/reverse-debugging.html" rel="alternate"></link><published>2009-07-12T21:55:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-12:/blog/reverse-debugging.html/</id><summary type="html">&lt;p&gt;A few weeks ago I happened to be in Palo Alto and met up with my friend
and long-time GDB hacker Michael Snyder. He told me about a new feature
in GDB called "process recording". The basic idea is that when you tell
GDB to enter into "record mode", it …&lt;/p&gt;</summary><category term="gdb"></category></entry><entry><title>A Disassembler in Verilog</title><link href="http://moxielogic.github.io/blog/a-disassembler-in-verilog.html" rel="alternate"></link><published>2009-06-22T18:55:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-06-22:/blog/a-disassembler-in-verilog.html/</id><summary type="html">&lt;p&gt;I've been playing around a little more with verilog. Here's a mostly
complete moxie &lt;a href="http://github.com/atgreen/moxiedev/blob/fb57efc73e47e451f18951d274c41ccda337c112/moxie/rtl/verilog/iprinter.v"&gt;disassembler module&lt;/a&gt; written in verilog.&lt;/p&gt;
&lt;p&gt;And here's a little &lt;a href="http://github.com/atgreen/moxiedev/blob/fb57efc73e47e451f18951d274c41ccda337c112/moxie/rtl/verilog/testsuite/moxie.modules/test-iprinter.v"&gt;driver&lt;/a&gt; for it. The driver reads a hex dump file
into an array representing memory. On every clock cycle it updates the
instruction and data output registers …&lt;/p&gt;</summary></entry><entry><title>ISA improvements</title><link href="http://moxielogic.github.io/blog/isa-improvements.html" rel="alternate"></link><published>2009-06-11T05:19:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-06-11:/blog/isa-improvements.html/</id><summary type="html">&lt;p&gt;I've committed the PC-relative branch instruction changes upstream. But
this is just one of many ISA improvements that need to happen. Here are
a handful of other ideas off the top of my head. None of these projects
should be particularly difficult.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shorten load/store offsets to 16-bits. They are …&lt;/li&gt;&lt;/ul&gt;</summary><category term="architecture"></category></entry><entry><title>Moxie GCC port is upstream!</title><link href="http://moxielogic.github.io/blog/moxie-gcc-port-is-upstream.html" rel="alternate"></link><published>2009-06-09T21:41:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-06-09:/blog/moxie-gcc-port-is-upstream.html/</id><summary type="html">&lt;p&gt;The moxie port has been &lt;a href="http://gcc.gnu.org/ml/gcc/2009-06/msg00194.html"&gt;accepted by the GCC steering committee&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;I just &lt;a href="http://gcc.gnu.org/viewcvs?view=rev&amp;amp;revision=148339"&gt;checked it in&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That is all.&lt;/p&gt;</summary><category term="gcc"></category></entry><entry><title>Everything is relative (finally!)</title><link href="http://moxielogic.github.io/blog/everything-is-relative-finally.html" rel="alternate"></link><published>2009-06-07T17:57:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-06-07:/blog/everything-is-relative-finally.html/</id><summary type="html">&lt;p&gt;The Moxie ISA still needs quite a bit of tuning. Take branches, for
instance. A &lt;code&gt;beq&lt;/code&gt; instruction currently encoded &lt;a href="http://www.moxielogic.org/wiki/index.php?title=Instruction_Set#beq"&gt;like so&lt;/a&gt;...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;`00001111xxxxxxxx iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii`
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...where the "&lt;code&gt;x&lt;/code&gt;"s represent "don't care" bits, and "&lt;code&gt;i&lt;/code&gt;"s are a
32-bit absolute branch target. That's right -- branch targets are not PC
relative! This is …&lt;/p&gt;</summary><category term="architecture"></category><category term="binutils"></category><category term="gcc"></category><category term="u-boot"></category></entry><entry><title>An even newer git repo</title><link href="http://moxielogic.github.io/blog/an-even-newer-git-repo.html" rel="alternate"></link><published>2009-05-29T20:05:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-05-29:/blog/an-even-newer-git-repo.html/</id><summary type="html">&lt;p&gt;So it turns out that hosting a git repo that is only accessible via slow
http is no fun.&lt;/p&gt;
&lt;p&gt;Fortunately, the great team at &lt;a href="http://www.github.com"&gt;github.com&lt;/a&gt; were willing to take this
on, so now the real repository is accessible via this command:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git clone git://github.com/atgreen/moxiedev.git …&lt;/code&gt;&lt;/p&gt;</summary><category term="releng"></category></entry><entry><title>New git repo</title><link href="http://moxielogic.github.io/blog/new-git-repo.html" rel="alternate"></link><published>2009-05-26T20:05:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-05-26:/blog/new-git-repo.html/</id><summary type="html">&lt;p&gt;I'll bottom line this one quickly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt; is now maintained with git. Check it out like so..&lt;br&gt;
&lt;code&gt;$ git clone http://moxielogic.org/moxiedev.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;moxiedev now contains a partial &lt;a href="http://moxielogic.org/blog/?p=154"&gt;u-boot port&lt;/a&gt;. It's "partial"
    because I fat fingered some commands and blew away four or five
    important files. They will have …&lt;/li&gt;&lt;/ul&gt;</summary><category term="releng"></category><category term="u-boot"></category></entry><entry><title>RPMs</title><link href="http://moxielogic.github.io/blog/rpms.html" rel="alternate"></link><published>2009-05-07T17:37:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-05-07:/blog/rpms.html/</id><summary type="html">&lt;p&gt;There's a little more detail on the &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;wiki&lt;/a&gt;, but basically...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ rpm -ivh http://moxielogic.org/download/moxielogic-repo-1-1.noarch.rpm
$ yum groupinstall moxiedev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Your welcome.&lt;/p&gt;
&lt;p&gt;Seriously though... release engineering is at times both tedious and
fascinating. But mostly tedious. Still, I was interested in tackling a
little releng work this week …&lt;/p&gt;</summary><category term="releng"></category></entry><entry><title>Quick update...</title><link href="http://moxielogic.github.io/blog/quick-update.html" rel="alternate"></link><published>2009-04-29T22:38:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-29:/blog/quick-update.html/</id><summary type="html">&lt;p&gt;A few quick &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;MoxieDev&lt;/a&gt; updates...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The verilog output patch is in binutils&lt;/li&gt;
&lt;li&gt;The moxie ports for binutils, newlib, libgloss and gdb are all
    upstream. Waiting on sim and gcc reviews.&lt;/li&gt;
&lt;li&gt;The upstream qemu team have switched to git, so I've rebased
    MoxieDev's qemu against this new repository.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, I've been …&lt;/p&gt;</summary><category term="binutils"></category><category term="gdb"></category><category term="newlib"></category><category term="qemu"></category></entry><entry><title>Loading programs into the verilog simulation</title><link href="http://moxielogic.github.io/blog/loading-programs-into-the-verilog-simulation.html" rel="alternate"></link><published>2009-04-22T13:38:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-22:/blog/loading-programs-into-the-verilog-simulation.html/</id><summary type="html">&lt;p&gt;The moxie newlib port was &lt;a href="http://sourceware.org/ml/newlib/2009/msg00520.html"&gt;just accepted&lt;/a&gt;. The GCC port will take a
little longer to review, but I hope that it will get accepted early next
week. Already there has been some useful feedback resulting in a few
improvements. For instance, the moxie libgcc.a now provides the soft-fp …&lt;/p&gt;</summary><category term="binutils"></category><category term="gcc"></category><category term="newlib"></category><category term="verilog"></category></entry><entry><title>Pushing Bits Upstream</title><link href="http://moxielogic.github.io/blog/pushing-bits-upstream.html" rel="alternate"></link><published>2009-04-16T17:55:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-16:/blog/pushing-bits-upstream.html/</id><summary type="html">&lt;p&gt;If there's one thing I've learned about GNU tools development over the
years, it's that attempting to maintain a tools port outside of the
upstream tree is A Very Bad Idea! It's easy to let your private tree
fall out of sync from upstream. And the longer you wait to …&lt;/p&gt;</summary><category term="binutils"></category></entry><entry><title>A Verilogical Place To Start *</title><link href="http://moxielogic.github.io/blog/a-verilogical-place-to-start.html" rel="alternate"></link><published>2009-04-07T20:31:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-07:/blog/a-verilogical-place-to-start.html/</id><summary type="html">&lt;p&gt;I've written my first bit of &lt;a href="http://en.wikipedia.org/wiki/Verilog"&gt;verilog&lt;/a&gt; tonight. It's not much, really,
but it's a start. I'm using &lt;a href="http://www.icarus.com/eda/verilog/"&gt;Icarus Verilog&lt;/a&gt; (iverlog) to compile and
simulate the code. I also plan on using &lt;a href="http://www.gpleda.org/tools/gtkwave/index.html"&gt;GTKWave&lt;/a&gt; to examine timing
dumps from the iverilog simulator. Both of these tools are part of my
development …&lt;/p&gt;</summary><category term="verilog"></category></entry><entry><title>Das U-Boot on moxie!</title><link href="http://moxielogic.github.io/blog/das-u-boot-on-moxie.html" rel="alternate"></link><published>2009-04-02T16:28:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-02:/blog/das-u-boot-on-moxie.html/</id><summary type="html">&lt;p&gt;My moxie port of &lt;a href="http://www.denx.de/wiki/U-Boot"&gt;U-Boot&lt;/a&gt;, the Universal Boot Loader, has started
working!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ qemu-system-moxie -nographic -kernel u-boot
SDRAM :
        U-Boot Start:0x00001000
Using default environment

U-BOOT &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;moxiesim&amp;quot;&lt;/span&gt;

&lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; version

U-Boot &lt;span class="m"&gt;2009&lt;/span&gt;.03-rc2-00013-gefb4734-dirty &lt;span class="o"&gt;(&lt;/span&gt;Apr &lt;span class="m"&gt;02&lt;/span&gt; &lt;span class="m"&gt;2009&lt;/span&gt; - &lt;span class="m"&gt;20&lt;/span&gt;:07:32&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; printenv
&lt;span class="nv"&gt;bootargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;root&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;romfs
&lt;span class="nv"&gt;baudrate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;38400&lt;/span&gt;
&lt;span class="nv"&gt;hostname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;moxiesim&amp;quot;&lt;/span&gt;

Environment size: &lt;span class="m"&gt;55&lt;/span&gt;/4092 &lt;span class="nv"&gt;bytes&lt;/span&gt;
&lt;span class="o"&gt;=&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It's …&lt;/p&gt;</summary><category term="u-boot"></category></entry><entry><title>Processor Exceptions</title><link href="http://moxielogic.github.io/blog/processor-exceptions.html" rel="alternate"></link><published>2009-04-02T08:33:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-02:/blog/processor-exceptions.html/</id><summary type="html">&lt;p&gt;My first go at exceptions is working well. The basic idea is that moxie
will have a single exception handling routine whose address lives in
special register 1. You set the exception handler like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void install_handler(void (*handler)(void))
{
  printf (&amp;quot;Installing handler 0x%x\n&amp;quot;, (unsigned) handler);
  asm(&amp;quot;ssr …&lt;/pre&gt;&lt;/div&gt;</summary><category term="architecture"></category></entry><entry><title>Thinking about exceptions....</title><link href="http://moxielogic.github.io/blog/thinking-about-exceptions.html" rel="alternate"></link><published>2009-03-19T14:01:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-19:/blog/thinking-about-exceptions.html/</id><summary type="html">&lt;p&gt;In reading about how other processors handle exceptions, they seem to be
of two sorts. Some (most?) processors look into a vector of exception
handlers based on the exception type (Divide by Zero, Software
Interrupt, IRQ, etc), and the other sort jumps to a single exception
address and lets the …&lt;/p&gt;</summary></entry><entry><title>Adding a Real Time Clock</title><link href="http://moxielogic.github.io/blog/adding-a-real-time-clock.html" rel="alternate"></link><published>2009-03-17T15:38:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-17:/blog/adding-a-real-time-clock.html/</id><summary type="html">&lt;p&gt;After a UART, one of the most useful and interesting peripherals you can
add to a board is a Real Time Clock (RTC). Qemu comes with a simulation
of Freescale's &lt;a href="http://www.freescale.com/files/microcontrollers/doc/data_sheet/MC146818.pdf"&gt;MC146818&lt;/a&gt; RTC chip. Adding it to our qemu-defined
board was as simple as....&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   rtc_mm_init(0x400, 0, 0, 0);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This makes …&lt;/p&gt;</summary><category term="bsp"></category><category term="qemu"></category></entry><entry><title>Board Support Packages</title><link href="http://moxielogic.github.io/blog/board-support-packages.html" rel="alternate"></link><published>2009-03-17T14:51:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-17:/blog/board-support-packages.html/</id><summary type="html">&lt;p&gt;Today we're introducing the notion of Board Support Packages (BSPs) to
the &lt;a href="http://moxielogic.org/wiki/index.php?title=Toolchain"&gt;moxie toolchain&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A BSP provides all of the configuration data and code requires to target
a specific hardware platform. This mostly involves linker scripts,
platform initialization code, and hardware abstraction support
libraries.&lt;/p&gt;
&lt;p&gt;Until recently the gdb sim was …&lt;/p&gt;</summary><category term="bsp"></category><category term="gdb"></category><category term="qemu"></category></entry><entry><title>Debugging with the moxie qemu simulator</title><link href="http://moxielogic.github.io/blog/debugging-with-the-moxie-qemu-simulator.html" rel="alternate"></link><published>2009-03-14T06:58:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-14:/blog/debugging-with-the-moxie-qemu-simulator.html/</id><summary type="html">&lt;p&gt;I've finally cracked the gdb+qemu puzzle, so now we can debug code
running on the qemu moxie simulator!&lt;/p&gt;
&lt;p&gt;The last little gotcha was that the simulated $pc wasn't being updated
after single-stepping. This will get you nowhere fast! But it's all
fixed now, and here's how it works...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ qemu-system-moxie …&lt;/code&gt;&lt;/p&gt;</summary><category term="gdb"></category><category term="qemu"></category></entry><entry><title>A Tiny Computer</title><link href="http://moxielogic.github.io/blog/a-tiny-computer.html" rel="alternate"></link><published>2009-03-13T14:48:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-13:/blog/a-tiny-computer.html/</id><summary type="html">&lt;p&gt;&lt;a href="http://lambda-the-ultimate.org/"&gt;Lambda the Ultimate&lt;/a&gt; today posted a interesting blog entry on &lt;a href="http://lambda-the-ultimate.org/node/3232"&gt;A Tiny
Computer&lt;/a&gt;. It refers to 2007 paper by Chuck Thacker at Microsoft
Research describing a tiny 32-bit processor. Appendix A of the paper
includes the entire synthesizeable verilog implementation in just a page
and a half of code! Here's …&lt;/p&gt;</summary><category term="verilog"></category></entry><entry><title>Progress...</title><link href="http://moxielogic.github.io/blog/progress.html" rel="alternate"></link><published>2009-03-12T20:34:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-12:/blog/progress.html/</id><summary type="html">&lt;p&gt;I made some progress on using moxie-elf-gdb with qemu the other day.
Qemu has an integrated gdb stub, so GDB speaks to it via the remote
protocol. It's still not quite there, but getting close. I'm anxious to
get it working, as it's the last step before hacking on the …&lt;/p&gt;</summary><category term="gcc"></category><category term="qemu"></category><category term="releng"></category></entry><entry><title>MoxieDev and the Wiki</title><link href="http://moxielogic.github.io/blog/moxiedev-and-the-wiki.html" rel="alternate"></link><published>2009-03-07T06:22:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-07:/blog/moxiedev-and-the-wiki.html/</id><summary type="html">&lt;p&gt;Now that the project has been renamed, the mercurial source repository
has also changed from ggxdev to MoxieDev. This repository contains the
entire toolchain, simulators and benchmark programs. You can check the
entire thing out like so...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ hg clone http://mercurial.intuxication.org/hg/moxiedev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I've also created a &lt;a href="http://moxielogic.org/wiki"&gt;wik …&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>Qemu says Hello, World!</title><link href="http://moxielogic.github.io/blog/qemu-says-hello-world.html" rel="alternate"></link><published>2009-03-07T06:22:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-07:/blog/qemu-says-hello-world.html/</id><summary type="html">&lt;p&gt;Virtually all of the simulation done so far was with the GDB instruction
set simulator. As a basic instruction set simulator, it was limited to
executing instructions found in typical "user level" applications. And,
if you recall, all interaction with the outside world happened through
magic software interrupts that were …&lt;/p&gt;</summary><category term="qemu"></category></entry><entry><title>Moxie: the ggx reboot</title><link href="http://moxielogic.github.io/blog/moxie-the-ggx-reboot.html" rel="alternate"></link><published>2009-03-07T05:23:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-07:/blog/moxie-the-ggx-reboot.html/</id><summary type="html">&lt;p&gt;Hola Amigos!  Several months ago I experimented with a new ISA design
called &lt;a href="http://spindazzle.org/ggx"&gt;ggx&lt;/a&gt;. I blogged about the co-evolution of the ISA and tools,
and it was fun.&lt;/p&gt;
&lt;p&gt;Now, after a short break, I'm ready to resume hacking.&lt;/p&gt;
&lt;p&gt;I'm also ready to put a stake in the ground as far …&lt;/p&gt;</summary></entry></feed>