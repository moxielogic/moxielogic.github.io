<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>The Moxie Blog</title><link href="http://moxielogic.github.io/blog/" rel="alternate"></link><link href="http://moxielogic.github.io/blog/feeds/moxie.atom.xml" rel="self"></link><id>http://moxielogic.github.io/blog/</id><updated>2015-02-15T15:21:00-05:00</updated><entry><title>Moxie talk at Bitcoin Dev Meetup</title><link href="http://moxielogic.github.io/blog/moxie-talk-at-bitcoin-dev-meetup.html" rel="alternate"></link><published>2015-02-15T15:21:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2015-02-15:blog/moxie-talk-at-bitcoin-dev-meetup.html</id><summary type="html">&lt;p&gt;&lt;center&gt;
&lt;img alt="" src="http://moxielogic.org/images/bcdev.jpg" /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;A very meta photo of me at the Toronto Bitcoin Developer Meetup
yesterday, explaining moxie, and the value of a security oriented VM
(moxiebox).&lt;/p&gt;
&lt;p&gt;Photo used by permission from Jan Miranda.&lt;/p&gt;</summary><category term="gcc"></category></entry><entry><title>An ELF Machine Number for Moxie</title><link href="http://moxielogic.github.io/blog/elf-machine-number.html" rel="alternate"></link><published>2015-01-09T15:21:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2015-01-09:blog/elf-machine-number.html</id><summary type="html">&lt;p&gt;Moxie was assigned an official ELF machine number this week!  You can
check it out here:
&lt;a href="http://www.sco.com/developers/gabi/latest/ch4.eheader.html"&gt;http://www.sco.com/developers/gabi/latest/ch4.eheader.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All ELF files start with a header describing properties of the object
at hand.  One of the most important properties is the 'machine' type.
The machine type identifies the basic architecture for which the given
binary is relevant.  It is represented as a 16-bit integer, so, for
instance, MIPS is 3, ARM is 40, AVR32 is 185, and now, I'm happy to
say, Moxie is 223.&lt;/p&gt;
&lt;p&gt;Linkers, loaders, and similar tools examine the machine number to make
sure they're working with the right kinds of files.  This saves us
from linking SH4 and Sparc objects into x86_64 executables.&lt;/p&gt;
&lt;p&gt;Until recently the Moxie GNU binutils port had been using a temporary
machine number of 0xFEED.  Every new architecture, however, should get
an official number assigned by the System V gABI maintainers.  Just
send a nice email requesting the number assignment to registry@sco.com
and they'll increment their most recent number and add you to the
list.&lt;/p&gt;
&lt;p&gt;If you look at GNU binutils you'll see that many ports, including
Moxie, live for quite some time using arbitrary machine number values
unlikely to conflict with the slowly incrementing official numbers.
Others, like the FTDI FT32 port, get their numbers (222) assigned in
advance of port submission.  If you go the same route I did, you'll
see that binutils has a mechanism whereby you can identify the main
machine number (223) as well as alternative numbers (0xFEED) to ease
in the transition.  This is all that needed doing:
&lt;a href="https://sourceware.org/ml/binutils/2015-01/msg00105.html"&gt;https://sourceware.org/ml/binutils/2015-01/msg00105.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Happy Hacking!&lt;/p&gt;</summary><category term="gcc"></category></entry><entry><title>Compacting the code with shorter load/store offsets</title><link href="http://moxielogic.github.io/blog/shorter-load-store-offsets.html" rel="alternate"></link><published>2014-12-28T08:47:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-12-28:blog/shorter-load-store-offsets.html</id><summary type="html">&lt;p&gt;You may recall that moxie supports two instructions lengths: 16- and 48-bit.
Today I'm introducing a few 32-bit instructions as well.&lt;/p&gt;
&lt;p&gt;Previously, moxie's "load and store with offset" instructions were
defined as...&lt;/p&gt;
&lt;blockquote&gt;
&lt;table width='100%'&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;ldo.l&lt;/b&gt;&lt;/td&gt;&lt;td align='right'&gt;&lt;b&gt;00001100AAAABBBB iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
Load offset, long.  Loads into &lt;b&gt;$rA&lt;/b&gt; the 32-bit value from memory pointed at by the address produced by adding the 32-bit value following the 16-bit opcode to &lt;b&gt;$rB&lt;/b&gt;.
&lt;p&gt;
&lt;table width='100%'&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;sto.l&lt;/b&gt;&lt;/td&gt;&lt;td align='right'&gt;&lt;b&gt;00001101AAAABBBB iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
Store offset, long.  Stores the 32-bit contents of &lt;b&gt;$rB&lt;/b&gt; into memory at the address roduced by adding the 32-bit value following the 16-bit opcode to &lt;b&gt;$rA&lt;/b&gt;.
&lt;/blockquote&gt;

&lt;p&gt;In addition to these two, there are versions to load and store 16- and
8-bit values.&lt;/p&gt;
&lt;p&gt;In almost every &lt;code&gt;ldo&lt;/code&gt; and &lt;code&gt;sto&lt;/code&gt; case, however, the upper 16 bits of
the offset were either 0x0000 or 0xFFFF (for negative offsets).
You'll see a lot of these when we access local C variables accessed by
indexing off of &lt;code&gt;$fp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Shortening the offset from 32 to 16 bits has always been on my radar
but I was slow to implement because it's a backwards-incompatible
change, and focus has been on tool/core correctness - not
optimization.  But now it's time to clean things up, and I've
implemented this change in all of the upstream moxie tools.  I'm also
testing a MoxieLite core change as well and should be pushing it to
github shortly.&lt;/p&gt;
&lt;p&gt;The new ldo and sto instructions look like this (for example)...&lt;/p&gt;
&lt;blockquote&gt;
&lt;table width='100%'&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;ldo.l&lt;/b&gt;&lt;/td&gt;&lt;td align='right'&gt;&lt;b&gt;00001100AAAABBBB iiiiiiiiiiiiiiii&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
Load offset, long.  Loads into &lt;b&gt;$rA&lt;/b&gt; the 32-bit value from memory pointed at by the address produced by adding the 16-bit value following the 16-bit opcode to &lt;b&gt;$rB&lt;/b&gt;.
&lt;p&gt; 
&lt;table width='100%'&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;sto.l&lt;/b&gt;&lt;/td&gt;&lt;td align='right'&gt;&lt;b&gt;00001101AAAABBBB iiiiiiiiiiiiiiii&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
Store offset, long.  Stores the 32-bit contents of &lt;b&gt;$rB&lt;/b&gt; into memory at the address roduced by adding the 16-bit value following the 16-bit opcode to &lt;b&gt;$rA&lt;/b&gt;.
&lt;/blockquote&gt;</summary><category term="moxie"></category><category term="architecture"></category></entry><entry><title>Multiplication in the Real World</title><link href="http://moxielogic.github.io/blog/real-world-multiply.html" rel="alternate"></link><published>2014-12-24T08:47:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-12-24:blog/real-world-multiply.html</id><summary type="html">&lt;p&gt;The bitcoin team has been exercising moxie in ways that it hasn't been
stressed before.  For example, they've been examining the code quality
for their crypto libraries like
&lt;a href="https://github.com/bitcoin/secp256k1"&gt;libsecp256k1&lt;/a&gt;, an elliptical
curve crypto library in C.  One of their first feedbacks here was that
moxie provides no native way to get a 64-bit result from a 32-bit
multiply.  One of the developers noted that...&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;ARM has umull which returns results into two registers&lt;/li&gt;
&lt;li&gt;PowerPC has no double-width result multiply, but does have mullw and mulhw instructions to compute the low and high word respectively&lt;/li&gt;
&lt;li&gt;MIPS's multiplication goes into special hi and lo registers, which can be loaded into general-purpose registers later&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;From an instruction count perspective, moxie's failing here was
painfully obvious. But how to go about addressing this?&lt;/p&gt;
&lt;p&gt;The MIPS and ARM approaches require register pairs to hold results.
Moxie has two-operand instructions, and if I went this way the second
register would have to be inferred somehow (&lt;code&gt;$rA&lt;/code&gt; and &lt;code&gt;$r[A+1]&lt;/code&gt;?).  Or
maybe we could dedicate special registers for multiplication results?
Neither approach is very appealing.  I decided to go with the Power
approach (also used by NIOS2 and perhaps others), and introduce new
instructions (&lt;code&gt;mul.x&lt;/code&gt; and &lt;code&gt;umul.x&lt;/code&gt;) that multiply two 32-bit values
and delivers the upper 32 bits of a 64-bit result (signed and
unsigned).  The compiler change was pretty straight forward, and can
be seen here:
&lt;a href="https://gcc.gnu.org/ml/gcc-patches/2014-12/msg01850.html"&gt;https://gcc.gnu.org/ml/gcc-patches/2014-12/msg01850.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that the compiler only generates these instructions when provided
with &lt;code&gt;-mmul.x&lt;/code&gt;, which is enabled by default for moxiebox-elf targets.&lt;/p&gt;
&lt;p&gt;The end result is that key functions in the secp256k1 code halved in
length!  We'll continue looking at code quality and tweaking the
architecture when it makes sense.&lt;/p&gt;</summary><category term="moxie"></category><category term="gcc"></category><category term="architecture"></category></entry><entry><title>Moxiebox and bitcoin</title><link href="http://moxielogic.github.io/blog/moxiebox-and-bitcoint.html" rel="alternate"></link><published>2014-12-18T05:00:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-12-18:blog/moxiebox-and-bitcoint.html</id><summary type="html">&lt;p&gt;&lt;center&gt;
&lt;img alt="http://bitcoin.org" src="http://moxielogic.org/images/Bitcoin-logo.jpg" /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;One of the more interesting developments around moxie is the adoption
of the &lt;a href="http://moxielogic.org/blog/pages/architecture.html"&gt;moxie
architecture&lt;/a&gt; by
the core bitcoin developers (&lt;a href="http://garzikrants.blogspot.ca/"&gt;Jeff
Garzik&lt;/a&gt;, in particular), for an
experimental project called
&lt;a href="http://github.com/jgarzik/moxiebox"&gt;&lt;code&gt;moxiebox&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To quote Jeff...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal is to provide a secure, sandboxed execution mechanism that enables deterministic input, processing and output. Execution is separated out into distinct phases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Prepare and load hash-sealed program executables, data.&lt;/li&gt;
&lt;li&gt;Execute program as a black box, with no I/O capability. Runs until exit or CPU budget exhausted (or CPU exception).&lt;/li&gt;
&lt;li&gt;Gather processed data, if any.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A single thread of execution pre-loads necessary data, then simulates a 32-bit little endian Moxie CPU, running the loaded code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I don't pretend to have deep understand bitcoin technology, but my
basic understanding is that moxiebox could be used to implement
automated smart contracts.  For instance, signed moxiebox executables
controlling a certain number of bitcoins could be distributed in the
&lt;a href="http://en.wikipedia.org/wiki/Bitcoin#The_block_chain"&gt;block chain&lt;/a&gt;.
These programs would decide what to do with the bitcoins based on
program execution against certain input.  People could independently
verify the results of this program because it's all designed to be
completely deterministic and reproducible.&lt;/p&gt;
&lt;p&gt;From a moxie tooling perspective, I added a moxiebox target to the GNU
toolchain to simplify its use.  The moxiebox project supplies the
simulator, as well as crt0 and some custom moxie runtime libraries.
The 'moxiebox-gcc' compiler is configured to link everything in the
right order, including newlib, the custom crt0 and sandbox runtime
library.&lt;/p&gt;
&lt;p&gt;It's not clear how things will develop, but one thing that's come up
is extending the moxie ISA to include new instructions in support of
crypto activities.  We'll just have to see.  You can follow along at
&lt;a href="http://github.com/jgarzik/moxiebox"&gt;http://github.com/jgarzik/moxiebox&lt;/a&gt;.&lt;/p&gt;</summary><category term="moxiebox"></category><category term="bitcoin"></category></entry><entry><title>Sign Extension</title><link href="http://moxielogic.github.io/blog/sign-extension.html" rel="alternate"></link><published>2014-04-04T00:40:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-04-04:blog/sign-extension.html</id><summary type="html">&lt;p&gt;Moxie zero-extends all 8 and 16-bit loads from memory. Until recently,
however, the GCC port didn't understand how loads worked, and would
always shift loaded values back and forth to either empty out the upper
bits or sign-extend the loaded value. While correct, it was overly
bloated. If we're loading an unsigned char into a register, there's no
need to force the upper bits to clear. The hardware does this for us.&lt;/p&gt;
&lt;p&gt;For instance, this simple C code....&lt;/p&gt;
&lt;p&gt;
&lt;script src="https://gist.github.com/atgreen/9970355.js"&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;..would compile to...&lt;/p&gt;
&lt;p&gt;
&lt;script src="https://gist.github.com/atgreen/9970378.js"&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;Thanks to help from hackers on the &lt;a href="http://gcc.gnu.org/ml/gcc/2014-04/msg00008.html"&gt;GCC mailing list&lt;/a&gt;, I was finally
able to teach the compiler how to treat memory loads correctly. This led
to two changes...&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The introduction of 8 and 16-bit sign extension instructions
    (&lt;code&gt;sex.b&lt;/code&gt; and &lt;code&gt;sex.s&lt;/code&gt;). Sometimes we really do need to sign-extend
    values, and logical shift left followed by arithmetic shift right is
    a pretty expensive way to do this on moxie.&lt;/li&gt;
&lt;li&gt;The char type is now unsigned by default. If you have zero-extending
    8-bit loads then you had better make your char type unsigned,
    otherwise your compiler output will be littered with sign extension
    instructions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Now for the C code above, we get this nice output....

&lt;script src="https://gist.github.com/atgreen/9970471.js"&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;I believe that this was the last major code quality issue from the GCC
port, and the compiler output should be pretty good now&lt;/p&gt;
&lt;p&gt;I've updated the upstream GCC, binutils and gdb (sim) repositories, my
&lt;a href="http://github.com/atgreen/qemu-moxie"&gt;QEMU&lt;/a&gt; fork in github, as well as the MoxieLite VHDL core in the
&lt;a href="http://github.com/atgreen/moxie-cores"&gt;moxie-cores&lt;/a&gt; git repo.&lt;/p&gt;</summary></entry><entry><title>NetHack in your browser</title><link href="http://moxielogic.github.io/blog/nethack-in-your-browser.html" rel="alternate"></link><published>2014-01-26T18:12:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-01-26:blog/nethack-in-your-browser.html</id><summary type="html">&lt;p&gt;This is a moxie-rtems port of NetHack running on a modified version of
the gdb moxie simulator compiled to javascript with &lt;a href="https://github.com/kripken/emscripten" title="emscripten"&gt;emscripten&lt;/a&gt;.&lt;/p&gt;
&lt;canvas id="tty" class="screen" width="640" height="384"&gt;
                        Terminal uses canvas
                    &lt;/canvas&gt;

&lt;script src="http://kl7107.github.io/moxie-sim/c/terminal.js"&gt;&lt;/script&gt;

&lt;script src="http://kl7107.github.io/moxie-sim/c/terminal-input.js"&gt;&lt;/script&gt;

&lt;script src="http://kl7107.github.io/moxie-sim/c/moxie.js"&gt;&lt;/script&gt;

&lt;script src="http://kl7107.github.io/moxie-sim/c/nethack.js"&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href="http://github.com/kl7107"&gt;Krister Lagerström&lt;/a&gt; is responsible for this marvellous hack.&lt;/p&gt;
&lt;p&gt;Also, I suppose this blog entry represents a distribution of some GPL'd
source code from GDB, so I need to tell you about the:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/kl7107/moxie-sim"&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.gnu.org/licenses/"&gt;License&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.gnu.org/music/gdb-song.html"&gt;Song&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And then there's RTEMS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://github.com/atgreen/RTEMS"&gt;Source&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.rtems.org/license"&gt;License&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And finally NetHack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/kl7107/nethack-moxie"&gt;Source&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.nethack.org/common/license.html"&gt;License&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="gdb"></category><category term="NetHack"></category><category term="RTEMS"></category></entry><entry><title>The Moxie Game Console?</title><link href="http://moxielogic.github.io/blog/the-moxie-game-console.html" rel="alternate"></link><published>2014-01-11T06:06:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2014-01-11:blog/the-moxie-game-console.html</id><summary type="html">&lt;p&gt;Ok, not quite, but &lt;a href="https://github.com/kl7107" title="Krister"&gt;Krister Lagerström&lt;/a&gt; recently did something cool..&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="nethack" src="http://moxielogic.github.io/images/nethack.png" /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;That's &lt;a href="http://www.nethack.org/" title="NetHack"&gt;NetHack&lt;/a&gt; ported to &lt;a href="http://rtems.org" title="RTEMS"&gt;RTEMS&lt;/a&gt; running on the moxie based &lt;a href="http://github.org/atgreen/moxie-cores" title="Marin SoC"&gt;Marin
SoC&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It runs on QEMU, via
"&lt;code&gt;qemu-system-moxie --nographic --machine marin --kernel nethack.elf&lt;/code&gt;",
or on FPGA hardware. I tested with a Nexys 3 Spartan-6 board by simply
converting it to an screcord file and sending it via the serial port to
the hardware's boot loader.&lt;/p&gt;
&lt;p&gt;Krister implemented the Marin BSP for RTEMS, then ported ncurses and
nethack to moxie-rtems. Like many programs with a UNIX heritage, NetHack
reads data files from a local file system. RTEMS solves that by
providing a simple in-memory filesystem you can initialize with a tar
file and link to your ELF executable.&lt;/p&gt;
&lt;p&gt;For my part, I had to fix a couple of QEMU bugs and point the
moxie-cores tools build scripts to staging git repos until the bugs are
fixed upstream. As usual, everything should be here:
&lt;a href="http://github.com/atgreen/moxie-cores"&gt;http://github.com/atgreen/moxie-cores&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thank you, Krister, and I'm looking forward to the other cool things you
have planned!&lt;/p&gt;</summary><category term="marin"></category><category term="NetHack"></category><category term="Nexys3"></category><category term="RTEMS"></category></entry><entry><title>Putting it together: on-chip firmware</title><link href="http://moxielogic.github.io/blog/putting-it-together-on-chip-firmware.html" rel="alternate"></link><published>2013-12-10T03:45:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-12-10:blog/putting-it-together-on-chip-firmware.html</id><summary type="html">&lt;p&gt;The on-chip &lt;a href="https://github.com/atgreen/moxie-cores/blob/master/firmware/bootrom/tinystub.c" title="firmware"&gt;firmware&lt;/a&gt; for the &lt;a href="https://github.com/atgreen/moxie-cores/tree/master/soc/marin" title="Marin SoC"&gt;Marin SoC&lt;/a&gt; has been updated with the
gdb stub, so now when you program the FPGA, you'll see the following on
the serial console:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;MOXIE On-Chip Bootloader v2.0
Copyright (c) 2013 Anthony Green

Waiting for an S-Record Download or Remote GDB Connection...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...and the Nexys3 7 segment display reads "FEEd". At this point you can
send down an srecord encoded binary that will then start running at
0x30000000 (7 segment display reads "3000"), or connect with
moxie-elf-gdb (7 segment display reads "dEb2"). A typical gdb session
looks like this:&lt;/p&gt;
&lt;p&gt;
&lt;script src="https://gist.github.com/atgreen/7889219.js"&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;The final bit of the puzzle was a missing feature in the on-chip RAM
controller -- not external RAM, but RAM cobbled together from FPGA logic
which is used by the on-chip firmware for stack &amp;amp; heap. I had left out
byte-level access in my initial design, so every read/write was 16-bits
- potentially wiping out memory unintentionally. Once I &lt;a href="https://github.com/atgreen/moxie-cores/commit/4ec58e177d44d04532b3490e9a11df13d35fb63c"&gt;figure this
out&lt;/a&gt;, everything started to work.&lt;/p&gt;
&lt;p&gt;I'm done with the on-chip bootloading firmware for now!&lt;/p&gt;</summary><category term="gdb"></category><category term="marin"></category><category term="Nexys3"></category><category term="r"></category></entry><entry><title>A Really Tiny GDB Remote Protocol Stub</title><link href="http://moxielogic.github.io/blog/a-really-tiny-gdb-remote-protocol-stub.html" rel="alternate"></link><published>2013-11-28T18:44:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-11-28:blog/a-really-tiny-gdb-remote-protocol-stub.html</id><summary type="html">&lt;p&gt;I recently trimmed the Marin SoC's on-chip memory down to 4k. The
existing firmware for downloading srecord programs into external RAM for
execution was taking up about 2k. With 2k to spare, I was wondering if
you could fit a GDB remote protocol stub in there as well. It turns out
that you can! Here is the code for tinystub.c:
&lt;a href="https://raw.github.com/atgreen/moxie-cores/master/firmware/tinystub.c"&gt;https://raw.github.com/atgreen/moxie-cores/master/firmware/tinystub.c&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With this stub you can load programs into the target device, examine
memory, run programs and even set breakpoints (I had to finally
implement BRK in the moxielite core for this).&lt;/p&gt;
&lt;p&gt;A full tinystub executable (with startup code, etc), is about 2200 bytes
of moxie code. This means I can easily merge it with the existing
firmware, allowing people to either download an srecord program or
connect to the device with moxie-elf-gdb. I believe everything is in
place now to support running the GCC testsuite on hardware (dejagnu will
use gdb to download an execute test programs).&lt;/p&gt;</summary><category term="gdb"></category><category term="marin"></category></entry><entry><title>Moxie on Altera's Cyclone II, and a Chance Encounter</title><link href="http://moxielogic.github.io/blog/moxie-on-alteras-cyclone-ii-and-a-chance-encounter.html" rel="alternate"></link><published>2013-08-08T18:59:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-08-08:blog/moxie-on-alteras-cyclone-ii-and-a-chance-encounter.html</id><summary type="html">&lt;p&gt;I recently fired up the Altera software, Quartus II, and spent a little
time porting the Marin SoC to the popular Cyclone II based DE2 board.
There's no external memory support yet, but on-chip memory is working,
and it looks like the on-chip bootloader is coming up properly. As
usual, everything has been committed to github at
&lt;a href="http://github.com/atgreen/moxie-cores"&gt;http://github.com/atgreen/moxie-cores&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I was riding the subway to a meeting downtown today after a late night
of messing around with Quartus II when I noticed a guy with an Altera
bag sitting next to me --- the Baader-Meinhof phenomenon in action! So I
struck up a conversation, and it turns out he works on the Quartus II
place-and-route software here in the Toronto office. Small world!&lt;/p&gt;
&lt;p&gt;Also, I just noticed something extremely cool in Fedora rawhide (the
incubator that will produce Fedora 20):
'&lt;code&gt;yum install qemu-system-moxie&lt;/code&gt;` works! It's packaged up as part of
the latest QEMU release in Fedora.&lt;/p&gt;</summary><category term="Altera"></category><category term="de2"></category><category term="marin"></category><category term="qemu"></category><category term="Quartus"></category></entry><entry><title>QEMU 1.5 includes Moxie support</title><link href="http://moxielogic.github.io/blog/qemu-1-5-includes-moxie-support.html" rel="alternate"></link><published>2013-05-21T04:16:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-05-21:blog/qemu-1-5-includes-moxie-support.html</id><summary type="html">&lt;p&gt;QEMU 1.5 was just released the other day, and in the &lt;a href="http://lists.nongnu.org/archive/html/qemu-devel/2013-05/msg02557.html"&gt;"And much
more..."&lt;/a&gt; category I'm happy to say that it includes Moxie support!&lt;/p&gt;
&lt;p&gt;This release contains basic Moxie core support, with the imaginary
"moxiesim" board support. I have some local changes that provide Marin
SoC emulation, and can run the &lt;a href="http://moxielogic.org/blog/?p=738"&gt;on-chip bootloader I recently wrote
about&lt;/a&gt;. In this example, for instance, we're sending the u-boot
bootloader program in srecord format to qemu's emulated serial port on
stdin. It looks just like the real hardware does...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cat ~/u-boot.srec &lt;span class="p"&gt;|&lt;/span&gt; qemu-system-moxie --machine marin --kernel bootrom.elf --nographic
MOXIE On-Chip Bootloader v1.0
Copyright &lt;span class="o"&gt;(&lt;/span&gt;c&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="m"&gt;2013&lt;/span&gt; Anthony Green

Waiting &lt;span class="k"&gt;for&lt;/span&gt; S-Record Download...
Jumping to code at 0x30000000.
SDRAM :
    U-Boot Start:0x30000000
Using default environment

U-BOOT &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;marin&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;=&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We're just a few baby steps away from being able to do really cool
things!&lt;/p&gt;</summary><category term="marin"></category><category term="qemu"></category><category term="u-boot"></category></entry><entry><title>An On-Chip Bootloader</title><link href="http://moxielogic.github.io/blog/an-on-chip-bootloader.html" rel="alternate"></link><published>2013-05-06T02:25:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-05-06:blog/an-on-chip-bootloader.html</id><summary type="html">&lt;p&gt;Good news: we can access external memory! The logic for my pseudo-static
RAM controller is working, and big programs can finally run on hardware.&lt;/p&gt;
&lt;p&gt;You may recall that I had previously only been accessing fake memory
that was configured directly out of limited FPGA resources. I could
squeeze a tiny C program in there, but not use anything like newlib, the
embedded C runtime library. This new memory controller lets the
moxie-based Marin SoC access 16MB of external RAM on the Nexys3 board.&lt;/p&gt;
&lt;p&gt;When we were limited to on-chip resources, the C binary would be coupled
with the synthesized logic and loaded directly into the FPGA. This means
any changes to the code meant resynthesizing the logic to rebuild the
FPGA bitstream (I think there are ways around this, but I never got
there with my work-flow). Now that I have access to external RAM, I can
separate my code from my logic.&lt;/p&gt;
&lt;p&gt;The trick is to use an on-chip bootloader - code that is loaded with the
FPGA bitstream as described above. It does some basic hardware
initialization, and sends this message to the serial port:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MOXIE On-Chip Bootloader v1.0 Copyright (c) 2013 Anthony Green&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Waiting for S-Record Download...&lt;br /&gt;
&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;At which point I can send any program I like over my laptop's serial
port in the form of an S-Record ASCII file. This generally looks
like...  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ moxie-elf-gcc -Os hello.c marin.S -T../../moxie-marin.ld -o hello.elf -lnosys $ moxie-elf-objcopy -O srec --srec-forceS3 hello.elf hello.srec $ cat hello.srec &amp;gt; /dev/ttyUSB1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And then, back on the Nexys3 serial port I see:&lt;br /&gt;
&lt;code&gt;Jumping to code at 0x30000000. Hello World!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A couple of things can happen now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;with a little bit of dejagnu hacking, we can get the GCC testsuite
    to run directly on hardware. The simple thing here is to just have
    libgloss' _exit() jump back to the on-chip bootloader @ 0x1000.&lt;/li&gt;
&lt;li&gt;test the "stage-2" bootloader, u-boot. U-Boot was one of the first
    programs I ever ported to moxie. I've run it on the simulator, but
    never on hardware.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As usual, everything is in the moxie-cores github repo here:
&lt;a href="http://github.com/atgreen/moxie-cores"&gt;http://github.com/atgreen/moxie-cores&lt;/a&gt;.&lt;/p&gt;</summary><category term="marin"></category><category term="newlib"></category><category term="u-boot"></category></entry><entry><title>And time ticks on...</title><link href="http://moxielogic.github.io/blog/and-time-ticks-on.html" rel="alternate"></link><published>2013-03-29T20:12:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-03-29:blog/and-time-ticks-on.html</id><summary type="html">&lt;p&gt;The interrupt controller &lt;a href="https://github.com/atgreen/moxie-cores/commit/0e44d0f29a2f05ef7f99fb1fc5d670d7f99d7c0b"&gt;is working now&lt;/a&gt;, as is the timer and my
exception handling firmware. So now I'm able to write a basic stop-watch
application, where the 7-segment display simply increments the count
every second. Yes, this sounds basic, but there's a lot of complexity
under the hood! This is all with the MoxieLite-based Marin SoC. Next up:
one of the following...&lt;/p&gt;
&lt;p&gt;​1. Finish the hardware GDB remote protocol handler, or&lt;br /&gt;
2. Implement a Marin board emulator in QEMU, or&lt;br /&gt;
3. Add support for external RAM (I'm currently just using limited FPGA
BRAM), or&lt;br /&gt;
4. Add interrupt support and timer ticks to RTEMS, or&lt;br /&gt;
5. Hook up the bus watchdog to the processor (should this go through
the interrupt controller? Or directly to the core?)&lt;/p&gt;
&lt;p&gt;We shall see....&lt;/p&gt;</summary><category term="marin"></category><category term="MoxieLite"></category><category term="qemu"></category><category term="RTEMS"></category><category term="SoC"></category></entry><entry><title>Moxie ports and hardware developments</title><link href="http://moxielogic.github.io/blog/moxie-ports-and-hardware-developments.html" rel="alternate"></link><published>2013-03-24T04:25:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2013-03-24:blog/moxie-ports-and-hardware-developments.html</id><summary type="html">&lt;p&gt;It's been a while since my last update.. let me bring you up to speed.&lt;/p&gt;
&lt;p&gt;A couple of &lt;a href="http://sourceware.org/libffi" title="libffi"&gt;libffi&lt;/a&gt; releases got in the way of moxie hacking
(although libffi 3.0.13 now includes full moxie support!), but things
are picking up speed again.&lt;/p&gt;
&lt;p&gt;On the software side of things, the moxie &lt;a href="http://www.rtems.org" title="RTEMS"&gt;RTEMS&lt;/a&gt; and &lt;a href="http://www.qemu.org" title="QEMU"&gt;QEMU&lt;/a&gt; ports
have both been accepted upstream. So now it's possible to build, run and
debug RTEMS applications on QEMU purely with upstream project sources.
You may notice that I'm doing much less work in the &lt;a href="https://github.com/atgreen/moxiedev" title="moxiedev"&gt;moxiedev&lt;/a&gt;
repository these days. This was mostly just a staging area for moxie
software support (tools, OS), and there's little use for it now that
most everything is upstream. All of the moxie HDL work now happens in
the &lt;a href="https://github.com/atgreen/moxie-cores" title="moxie-cores"&gt;moxie-cores&lt;/a&gt; git tree.&lt;/p&gt;
&lt;p&gt;As for the hardware side of things, here are some of the recent changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href="https://github.com/atgreen/moxie-cores/tree/master/cores/MoxieLite" title="MoxieLite"&gt;MoxieLite&lt;/a&gt; core now supports &lt;a href="http://moxielogic.org/wiki/index.php/Instruction_Set#ssr" title="ssr"&gt;&lt;code&gt;ssr&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://moxielogic.org/wiki/index.php/Instruction_Set#gsr" title="gsr"&gt;&lt;code&gt;gsr&lt;/code&gt;&lt;/a&gt;
    instructions, along with a bank of 16 special registers. The special
    register uses are defined here:
    &lt;a href="http://moxielogic.org/wiki/index.php/Architecture"&gt;http://moxielogic.org/wiki/index.php/Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;And now that the special register support is in place, exceptions
    and the &lt;a href="http://moxielogic.org/wiki/index.php/Instruction_Set#swi" title="swi"&gt;&lt;code&gt;swi&lt;/code&gt;&lt;/a&gt; (software interrupt) instruction are working in
    hardware. Semantics are defined here:
    &lt;a href-"http: moxielogic.org wiki index.php exceptions" title="Exceptions" target="_blank"&gt;http://moxielogic.org/wiki/index.php/Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bad&lt;/code&gt; (illegal) instructions now cause an illegal instruction
    exception&lt;/li&gt;
&lt;li&gt;A simple interrupt controller has been added to the &lt;a href="https://github.com/atgreen/moxie-cores/tree/master/soc/marin" title="marin"&gt;marin&lt;/a&gt; SoC. I
    have the Nexys3 momentary switches hooked up as interrupt sources,
    so I can trigger interrupts and handle them in software by pressing
    those buttons.&lt;/li&gt;
&lt;li&gt;A trivial timer has been hooked up to the interrupt controller, so I
    can now generate 'tick' interrupts for RTEMS in support of
    preemptive multitasking (everything was cooperative up 'til now).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm actually just debugging the timer ticks right now, but it's very
close.&lt;/p&gt;
&lt;p&gt;And on a final note... while RTEMS is a great little embedded RTOS, it's
clear from this EE Times embedded survey that I'm going to have to
implement FreeRTOS support next:
&lt;a href="http://www.eetimes.com/electronics-news/4407897/Android--FreeRTOS-top-EE-Times--2013-embedded-survey"&gt;http://www.eetimes.com/electronics-news/4407897/Android--FreeRTOS-top-EE-Times--2013-embedded-survey&lt;/a&gt;.
I think that's what I'll tackle after I get RTEMS running preemptively.&lt;/p&gt;</summary><category term="binutils"></category><category term="FreeRTOS"></category><category term="gcc"></category><category term="marin"></category><category term="MoxieLite"></category><category term="newlib"></category><category term="Nexys3"></category><category term="RTEMS"></category></entry><entry><title>Native On-Chip GDB Remote Protocol Support</title><link href="http://moxielogic.github.io/blog/native-on-chip-gdb-remote-protocol-support.html" rel="alternate"></link><published>2012-11-24T05:47:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-11-24:blog/native-on-chip-gdb-remote-protocol-support.html</id><summary type="html">&lt;p&gt;A typical software debug solution for an embedded systems might involve
a &lt;a href="http://en.wikipedia.org/wiki/Joint_Test_Action_Group"&gt;JTAG&lt;/a&gt; connection to the board, and then some kind of protocol
translation software that handles communication between GDB's remote
serial protocol and the target JTAG port (see &lt;a href="http://openocd.sourceforge.net/"&gt;OpenOCD&lt;/a&gt;, for
instance). The FPGA systems I'm working with include JTAG ports, and the
vendors also provide JTAG IP cores for interfacing them to your digital
logic. On the other hand, these systems also have nice UARTs that are
easy to talk to. We have the opportunity to dramatically simplify the
debug toolchain by including support for GDB's remote protocol directly
on chip. This would be a hardware implementation of the protocol - no
software stubs required.&lt;/p&gt;
&lt;p&gt;The GDB Target Engine IP core is essentially a state machine that reads
GDB packets coming over the UART (a microusb connection to my laptop).
It has direct access to MoxieLite core through some additional wires for
extracting register values. It also acts as a bus master to read/write
directly to/from memory. The Marin SoC only has one bus master - the
moxie core. The nice thing here is that we don't have to add any new bus
arbitration logic for the second master, because only one master will
ever be active at a time. We're either running in debug mode (active
connection to GDB over the UART), in which case the GDB Target Engine is
the bus master, or we're running in regular mode, where the moxie core
is in control.&lt;/p&gt;
&lt;p&gt;The GDB remote protocol includes many commands these days, but only a
small number are required to be supported by the target: read/write
registers, read/write memory, step and continue.&lt;/p&gt;
&lt;p&gt;Current status is that I can connect GDB directly to the SoC using
"target remote /dev/ttyUSB0", at which point GDB negotiates with the
target to determine what features are supported. I can hit Ctrl-C in GDB
to tell the SoC to enter debug mode. The Target Engine core then talks
to MoxieLite to extract register values, converts them to ASCII text and
sends them back to the debugger over the wire. This includes the PC, so
GDB knows where to go. Given that this is working, I'm not too worried
about the rest of it - but only time will tell...&lt;/p&gt;</summary><category term="gdb"></category><category term="JTAG"></category><category term="marin"></category><category term="SoC"></category></entry><entry><title>Running a C Program on the Marin SoC</title><link href="http://moxielogic.github.io/blog/running-a-c-program-on-the-marin-soc.html" rel="alternate"></link><published>2012-11-15T21:10:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-11-15:blog/running-a-c-program-on-the-marin-soc.html</id><summary type="html">&lt;p&gt;I've just committed the bits required to run a &lt;a href="https://github.com/atgreen/moxie-cores/blob/master/firmware/mdata.c"&gt;C program&lt;/a&gt; on the
Marin SoC.&lt;/p&gt;
&lt;p&gt;Rather than hook up the Nexys3 external RAM module, I'm using extra
space on the FPGA itself for RAM. Most of the hard work was sorting out
the &lt;a href="https://github.com/atgreen/moxie-cores/blob/master/soc/marin/moxie-marin.ld"&gt;linker script&lt;/a&gt; magic required to generate an appropriate image.&lt;/p&gt;
&lt;p&gt;I've also added a &lt;a href="https://github.com/atgreen/moxie-cores/tree/master/cores/uart"&gt;UART with 1k hardware FIFO transmit and receive
buffers&lt;/a&gt;. The 1k is probably overkill, so I'll likely shrink them once
everything else is working.&lt;/p&gt;
&lt;p&gt;I've moved all memory mapped IO devices up to 0xF0000000. So, for
instance, the 7-segment display LED is at 0xF0000000, and the UART
transmit register is at 0xF0000004. I'll just keep going from there.&lt;/p&gt;
&lt;p&gt;Next comes libgloss hacking to map stdout/stdin to the UART (which I
talk to with minicom on my Linux box). We're very close to "Hello World"
now!&lt;/p&gt;</summary><category term="fpga"></category><category term="gcc"></category><category term="marin"></category><category term="newlib"></category><category term="Nexys3"></category><category term="SoC"></category></entry><entry><title>Moxie SoC Progress</title><link href="http://moxielogic.github.io/blog/moxie-soc-progress.html" rel="alternate"></link><published>2012-11-10T05:23:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-11-10:blog/moxie-soc-progress.html</id><summary type="html">&lt;p&gt;Time for a quick update!&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;iframe width="560" height="315" src="http://www.youtube.com/embed/86-OkQcXEes" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;"Marin" is the name of my test SoC consisting of a &lt;a href="http://en.wikipedia.org/wiki/Wishbone_(computer_bus)" title="wishbone"&gt;wishbone&lt;/a&gt; wrapped
75Mhz big-endian MoxieLite bus master, along with two slave devices:
embedded ROM and the Nexys3's 7-segment display. So, right now I can
write some code into FPGA embedded ROM to manipulate the display. For
example...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;        .text&lt;/span&gt;
&lt;span class="x"&gt;    .p2align        1&lt;/span&gt;
&lt;span class="x"&gt;        .global MarinDisplayTest&lt;/span&gt;

&lt;span class="x"&gt;        .equ BIG_ENDIAN,1&lt;/span&gt;

&lt;span class="x"&gt;        &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; This is where 7-segment display is mapped to memory&lt;/span&gt;
&lt;span class="x"&gt;        .equ DISPLAY_ADDR,0x00100000&lt;/span&gt;

&lt;span class="x"&gt;MarinDisplayTest:&lt;/span&gt;
&lt;span class="x"&gt;        ldi.l   &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;r1&lt;/span&gt;&lt;span class="x"&gt;, 0x1234&lt;/span&gt;
&lt;span class="x"&gt;        ldi.l   &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;r3&lt;/span&gt;&lt;span class="x"&gt;, 0x0&lt;/span&gt;
&lt;span class="x"&gt;loop:   sta.s   DISPLAY_ADDR, &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;r1&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;        dec     &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;r1&lt;/span&gt;&lt;span class="x"&gt;, 1&lt;/span&gt;
&lt;span class="x"&gt;        ldi.l   &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;r2&lt;/span&gt;&lt;span class="x"&gt;, 5000000&lt;/span&gt;
&lt;span class="x"&gt;delay:  dec     &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;r2&lt;/span&gt;&lt;span class="x"&gt;, 1&lt;/span&gt;
&lt;span class="x"&gt;        cmp     &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;r2&lt;/span&gt;&lt;span class="x"&gt;, &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;r3&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;        bne     delay&lt;/span&gt;
&lt;span class="x"&gt;        jmpa    loop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This displays a countdown on the hex display starting at 1234.&lt;/p&gt;
&lt;p&gt;Here's what I think will be next:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I need to be able to access RAM, which means implementing a module
    to support the Nexys3's &lt;a href="http://www.micron.com/products/dram/psram-cellularram" title="CellularRAM"&gt;CellularRAM&lt;/a&gt; device and wrapping that up
    as a wishbone slave.&lt;/li&gt;
&lt;li&gt;Once I can access RAM, I can test C compiler output, but only small
    code that I can embed into the FPGA's ROM.&lt;/li&gt;
&lt;li&gt;Next comes a UART wishbone slave so I can talk to it over the
    microusb serial port from my Linux host. I'll need to hack up
    libgloss to map I/O to my memory-mapped UART.&lt;/li&gt;
&lt;li&gt;One of the annoying things about this Xilinx toolchain is that
    AFAICT Digilent doesn't provide the tool you need for programming
    memory (Flash, RAM, or otherwise) from your Linux host. So I plan on
    writing some ROMable firmware to download code (srecords?) over the
    UART (xmodem?) to program memory. This is the point at which we
    should be able to run larger programs. I already have a u-boot port,
    so I think that will be first on my list.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It's great to have Brad Robinson's MoxieLite implementation for Marin.
It's very small but can still run at quite a clip. Once the surrounding
infrastructure is working, however, I'm going to get back to Muskoka,
which is my 4-stage pipelined moxie SoC to see if I can crank up the
MHz.&lt;/p&gt;
&lt;p&gt;As usual everything is in github. However, the HDL cores and SoC designs
are no longer embedded in the moxiedev tree. They're in a new top-level
git repo called moxie-cores. Check it out here:
&lt;a href="http://github.com/atgreen/moxie-cores"&gt;http://github.com/atgreen/moxie-cores&lt;/a&gt;&lt;/p&gt;</summary><category term="fpga"></category><category term="marin"></category><category term="MoxieLite"></category><category term="Nexys3"></category><category term="SoC"></category><category term="u-boot"></category><category term="wishbone"></category><category term="Xilinx"></category></entry><entry><title>Moxie and Free Software EDA at FSOSS</title><link href="http://moxielogic.github.io/blog/moxie-and-free-software-eda-at-fsoss.html" rel="alternate"></link><published>2012-10-16T15:09:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-10-16:blog/moxie-and-free-software-eda-at-fsoss.html</id><summary type="html">&lt;p&gt;I'll be speaking at &lt;a href="http://fsoss.senecac.on.ca" title="FSOSS"&gt;FSOSS&lt;/a&gt; in Toronto next week on moxie and Free
Software EDA tools. Check it out here:
&lt;a href="http://fsoss.senecac.on.ca/2012/node/150"&gt;http://fsoss.senecac.on.ca/2012/node/150&lt;/a&gt;.&lt;/p&gt;</summary><category term="FSOSS"></category></entry><entry><title>MoxieLite in Action</title><link href="http://moxielogic.github.io/blog/moxielite-in-action.html" rel="alternate"></link><published>2012-09-22T04:40:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-09-22:blog/moxielite-in-action.html</id><summary type="html">&lt;p&gt;&lt;center&gt;
&lt;img alt="" src="http://moxielogic.org/images/MoxieLite-400.jpg" title="First MoxieLite Shot" /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Brad Robinson just sent me this awesome shot of &lt;a href="https://github.com/toptensoftware/MoxieLite" title="MoxieLite"&gt;MoxieLite&lt;/a&gt; in action.
His Xilinx Spartan-6 FPGA based SoC features a moxie core handling VGA
video, keyboard and FAT-on-flash filesystem duties using custom firmware
written in C. This is all in support of a second z80-based core on the
same FPGA used to emulate an '80s era computer called the &lt;a href="http://en.wikipedia.org/wiki/MicroBee"&gt;MicroBee&lt;/a&gt;.
Those files in the listing above are actually audio cassette contents
used to load the MicroBee software. The moxie core is essentially a
peripheral emulator for his final product.&lt;/p&gt;
&lt;p&gt;Keep up the great work, Brad!&lt;/p&gt;
&lt;p&gt;The most recent &lt;a href="http://gcc.gnu.org/ml/gcc-patches/2012-09/msg01572.html"&gt;compiler patch&lt;/a&gt; was the addition of &lt;code&gt;-mno-crt0&lt;/code&gt;,
which tells the compiler not to include the default C runtime startup
object at link time. This is common practice for many embedded projects,
where some system specific house keeping is often required before C
programs can start running. For instance, you may need to copy the
program's &lt;code&gt;.data&lt;/code&gt; section from ROM into RAM before jumping to &lt;code&gt;main()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I'm going back to my pipelined moxie implementation. Last I looked I had
to move memory reads further up the pipeline...&lt;/p&gt;</summary><category term="fpga"></category><category term="gcc"></category><category term="MoxieLite"></category><category term="vga"></category><category term="Xilinx"></category></entry><entry><title>It's Alive!</title><link href="http://moxielogic.github.io/blog/its-alive.html" rel="alternate"></link><published>2012-09-14T14:39:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-09-14:blog/its-alive.html</id><summary type="html">&lt;p&gt;There's a working hardware implementation of moxie in the wild!&lt;/p&gt;
&lt;p&gt;Intrepid hacker &lt;a href="https://twitter.com/toptensoftware" title="Brad Robinson"&gt;Brad Robinson&lt;/a&gt; created this moxie-compatible core as
a peripheral controller for his SoC. He had been using a simple 8-bit
core, but needed to address more memory than was possible with the 8-bit
part. Moxie is a nice alternative because it has a compact instruction
encoding, a supported GNU toolchain and a full 32-bit address space.
FPGA space was a real concern, so he started with a non-pipelined VHDL
implementation, and by all accounts it is running code and flashing LEDs
on a &lt;a href="http://www.digilentinc.com/Products/Detail.cfm?NavPath=2,400,897&amp;amp;Prod=NEXYS3" title="Nexys3"&gt;Nexys3 board&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;The one major "ask" was that there be a little-endian moxie architecture
and toolchain in addition to the default big-endian design. I had
somewhat arbitrarily selected big-endian for moxie, noting that this is
the natural byte order for TCP. In Brad's design, however, the moxie
core will handling FAT filesystem duties, which is largely a
little-endian task. At low clock speeds every cycle counts, so I agreed
to produce a bi-endian toolchain and, for the most part, it's all
committed in the upstream FSF repositories (with the exception of gdb
and the simulator). &lt;code&gt;moxie-elf-gcc&lt;/code&gt; is big-endian by default, but
compile with &lt;code&gt;-mel&lt;/code&gt; and you'll end up with little-endian binaries.&lt;/p&gt;
&lt;p&gt;Brad also suggested several other useful tweaks to the architecture,
including changing the PC-relative offsets encodings for branches. They
had originally been encoded relative to the start of the branch
instruction. Brad noted, however, that changing them to be relative to
the end of the branch instruction saved an adder in his design. I made
this change throughout the toolchain and (*cough*) documentation.&lt;/p&gt;
&lt;p&gt;I'll write more about this as it develops... Have to run now.&lt;/p&gt;
&lt;p&gt;Oh. Here's the VHDL on github:
&lt;a href="http://github.com/toptensoftware/MoxieLite"&gt;http://github.com/toptensoftware/MoxieLite&lt;/a&gt;. Go Brad!&lt;/p&gt;
&lt;p&gt;AG&lt;/p&gt;</summary><category term="architecture"></category><category term="fpga"></category><category term="gcc"></category><category term="gdb"></category><category term="Nexys3"></category><category term="SoC"></category><category term="VHDL"></category><category term="Xilinx"></category></entry><entry><title>The case against the [L]GPL for Semiconductor Core Licensing</title><link href="http://moxielogic.github.io/blog/the-case-against-the-lgpl-for-semiconductor-core-licensing.html" rel="alternate"></link><published>2012-09-09T19:35:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-09-09:blog/the-case-against-the-lgpl-for-semiconductor-core-licensing.html</id><summary type="html">&lt;p&gt;Eli Greenbaum wrote a terrific article for the Harvard Journal of Law &amp;amp;
Technology last fall called '&lt;a href="http://jolt.law.harvard.edu/articles/pdf/v25/25HarvJLTech131.pdf"&gt;Open Source Semiconductor Core
Licensing&lt;/a&gt;'. I'm using the GPL as a place-holder in my verilog source,
but I've always felt that the GPL/LGPL were inappropriate licenses for
digital logic. Eli's article makes clear arguments on why this is the
case.&lt;/p&gt;
&lt;p&gt;Here's the link to Eli's article:
&lt;a href="http://jolt.law.harvard.edu/articles/pdf/v25/25HarvJLTech131.pdf"&gt;http://jolt.law.harvard.edu/articles/pdf/v25/25HarvJLTech131.pdf&lt;/a&gt;&lt;/p&gt;</summary><category term="copyright"></category><category term="legal"></category><category term="licensing"></category></entry><entry><title>vfork() for uClinux forces an architecture change</title><link href="http://moxielogic.github.io/blog/vfork-for-uclinux-forces-an-architecture-change.html" rel="alternate"></link><published>2012-09-03T07:35:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-09-03:blog/vfork-for-uclinux-forces-an-architecture-change.html</id><summary type="html">&lt;p&gt;Moxie uses a simple software interrupt instruction (&lt;code&gt;swi&lt;/code&gt;) to implement
system calls. The &lt;code&gt;swi&lt;/code&gt; instruction creates a call frame on the stack
and then jumps to a global exception handler routine. The exception
handler for moxie-uClinux switches to the kernel stack before jumping to
the relevant kernel routine. Returning from an exception becomes a
simple &lt;code&gt;ret&lt;/code&gt; instruction because we have a nice call frame on our stack.
Very simple.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vfork()&lt;/code&gt;, a kludge that was ejected from posix, but is still required
for MMU-less uClinux ports, throws this for a loop. The &lt;code&gt;vfork&lt;/code&gt; system
call creates a child process that shares memory with the parent,
including a shared stack. This means that the &lt;code&gt;vfork&lt;/code&gt; system call
&lt;em&gt;returns twice on the shared stack&lt;/em&gt;: once for the child, and then again
for the parent. The problem is that the child, once returned, is going
to write over the &lt;code&gt;swi&lt;/code&gt; call frame on the shared stack as it continues
to do work. This sends the parent off into randomland when it eventually
returns using the corrupted call frame.&lt;/p&gt;
&lt;p&gt;Actually, it's not just the &lt;code&gt;swi&lt;/code&gt; call frame. There's also the &lt;code&gt;vfork()&lt;/code&gt;
stack frame from the C library to worry about.&lt;/p&gt;
&lt;p&gt;This problem isn't unique to moxie. If you examine the x86 uClibc
&lt;code&gt;vfork()&lt;/code&gt; implementation, you'll see that it stashes all the info it
needs for the return in registers that are preserved over the &lt;code&gt;vfork&lt;/code&gt;
system call.&lt;/p&gt;
&lt;p&gt;For moxie, I'll likely need to do the same thing in uClibc's &lt;code&gt;vfork()&lt;/code&gt;,
but I'm also going to change the semantics of the &lt;code&gt;swi&lt;/code&gt; instruction.
This means formalizing the notion of user mode and kernel mode. The
uClinux port already does this by convention. One of the special
registers is used to store the Linux kernel-mode stack pointer. The
&lt;code&gt;swi&lt;/code&gt; instruction will be changed to immediately switch stacks and push
the userland return info onto the non-shared kernel stack, leaving the
shared user stack completely untouched. The exception handler will have
a bit more house keeping to do, but &lt;code&gt;vfork()&lt;/code&gt; should work.&lt;/p&gt;</summary><category term="architecture"></category><category term="linux"></category></entry><entry><title>Forking bugs</title><link href="http://moxielogic.github.io/blog/forking-bugs.html" rel="alternate"></link><published>2012-08-15T20:59:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-08-15:blog/forking-bugs.html</id><summary type="html">&lt;p&gt;I found some time to look at the Linux kernel port again, and discovered
a bug in the forking code (the child process must return 0 after a
fork!). What we're looking at here is the start of userland, post kernel
boot, where busybox is trying to run an init script. It's still not
working, but some cool things are, like the stack trace. I think the
next troubling bit is where busybox tries to exec itself
(/proc/self/exe) and /proc isn't mounted. Or something like that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;___  ___           _              _____ _ _                  
|  \/  |          (_)            /  __ \ (_)                 
| .  . | ___ __  ___  ___   _   _| /  \/ |_ _ __  _   ___  __
| |\/| |/ _ \\ \/ / |/ _ \ | | | | |   | | | &amp;#39;_ \| | | \ \/ /
| |  | | (_) |&amp;gt;  &amp;lt;| |  __/ | |_| | \__/\ | | | | | |_| |&amp;gt;  &amp;lt; 
\_|  |_/\___//_/\_\_|\___|  \__,_|\____/_|_|_| |_|\__,_/_/\_\
sh: can&amp;#39;t execute &amp;#39;ls&amp;#39;: No such file or directory.
/bin/sh: option requires an argument -- c
BusyBox v1.19.0.git (2012-08-14 23:32:21 EDT) multi-call binary.

Usage: sh [-nxl] [-c &amp;#39;SCRIPT&amp;#39; [ARG0 [ARGS]] / FILE [ARGS]]

Unix shell interpreter

Kernel panic - not syncing: Attempted to kill init!
Rebooting in 120 seconds..
Machine restart...

Stack:
  03819e8c ffffffff 03819fb8 ffffffff ffffffff 03819ec0 0000408a 000fdfd2 
  0022438c 00000063 fa3c0000 00000000 00000000 03819ee4 03819ee4 0001e800 
  03bb8d14 0002990e ffffffff ffffffff 000003e8 000fceac 0001d4bf 03819f34 
Call Trace:

[&amp;lt;0000408a&amp;gt;] machine_restart+0x14/0x1a
[&amp;lt;000fdfd2&amp;gt;] bust_spinlocks+0x0/0x4a
[&amp;lt;0001e800&amp;gt;] emergency_restart+0xa/0xc
[&amp;lt;0002990e&amp;gt;] up_read+0x8/0xa
[&amp;lt;000fceac&amp;gt;] __muldi3+0x0/0x92
[&amp;lt;0001d4bf&amp;gt;] do_notify_parent+0x193/0x240
[&amp;lt;0004038c&amp;gt;] panic+0x11c/0x162
[&amp;lt;00012ea8&amp;gt;] exit_files+0x1e/0x26
[&amp;lt;000130c6&amp;gt;] do_exit+0x6e/0x706
[&amp;lt;0001377a&amp;gt;] sys_exit+0x0/0x18
[&amp;lt;00013792&amp;gt;] do_group_exit+0x0/0xac
[&amp;lt;00057fe2&amp;gt;] sys_write+0x0/0x96
[&amp;lt;000017fa&amp;gt;] .return_from_exception+0x0/0x18
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category></entry><entry><title>Multiported Registers, Microcode and Register Forwarding</title><link href="http://moxielogic.github.io/blog/multiported-registers-microcode-and-register-forwarding.html" rel="alternate"></link><published>2012-07-01T14:46:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-07-01:blog/multiported-registers-microcode-and-register-forwarding.html</id><summary type="html">&lt;p&gt;When I last wrote about tackling the 'pop' instruction I noted that I
needed the ability to write to multiple registers before retiring that
one instruction - something that would require extra instruction cycles
or loads more logic. I recently came across some work by Charles Eric
LaForest on &lt;a href="http://www.eecg.utoronto.ca/~laforest/multiport/index.html" title="Efficient Multi-Ported Memories for FPGAs"&gt;Efficient Multi-Ported Memories for FPGAs&lt;/a&gt;. His Live
Value Table (LVT) approach solves my problem quite neatly, and I was
able to adapt some of his sample code for a new register file
implementation that supports 2 simultaneous writes as well as 4 reads.&lt;/p&gt;
&lt;p&gt;One more recent change includes the addition of microcoded pipeline
control signals. I simply created a &lt;a href="https://raw.github.com/atgreen/moxiedev/master/moxie/cores/moxie/microcode.org" title="text file managed with emacs org-mode"&gt;text file managed with emacs
org-mode&lt;/a&gt; that describes pipeline control signals used for each
instruction. A little &lt;a href="https://github.com/atgreen/moxiedev/blob/master/scripts/microcoder.lisp" title="lisp script"&gt;lisp script&lt;/a&gt; reads this and turns it into a
binary table that is read during the instruction decode stage. Passing
the signals down the pipeline is much simpler than hand coding
behaviours in a big switch statement.&lt;/p&gt;
&lt;p&gt;Also, quite some time ago I wrote about handling Read-After-Write
pipeline hazards by inserting bubbles into the pipeline. I replaced that
with some &lt;a href="http://en.wikipedia.org/wiki/Hazard_%28computer_architecture%29#Register_forwarding" title="register forwarding"&gt;register forwarding&lt;/a&gt; logic, so you can read a register
immediately after writing to it without introducing any delays.&lt;/p&gt;
&lt;p&gt;So... progress is being made! I think I'll be running my first C program
soon.&lt;/p&gt;</summary><category term="muskoka"></category><category term="verilog"></category></entry><entry><title>Notes on a novel in-game CPU: the dcpu-16</title><link href="http://moxielogic.github.io/blog/notes-on-a-novel-in-game-cpu-the-dcpu-16.html" rel="alternate"></link><published>2012-04-09T07:35:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2012-04-09:blog/notes-on-a-novel-in-game-cpu-the-dcpu-16.html</id><summary type="html">&lt;p&gt;The hacker behind the &lt;a href="http://www.minecraft.net/"&gt;Minecraft&lt;/a&gt; phenomena, Notch, is working on his
&lt;a href="http://0x10c.com/"&gt;next game&lt;/a&gt;, most likely another hit. This one is interesting in that
it includes an in-game 16-bit processor called the dcpu-16. Details are
sparse, but it seems as though gamers will use this processor to control
spacecraft and play in-game games. The dcpu-16 spec is currently
available at &lt;a href="http://0x10c.com/doc/dcpu-16.txt"&gt;http://0x10c.com/doc/dcpu-16.txt&lt;/a&gt;, and in the few days
since its release there are already many community produced assemblers
and emulators.&lt;/p&gt;
&lt;p&gt;Like moxie, it's a load-store architecture with variable width
instructions (16 to 48 bits long). But the dcpu-16's 16-bitness is
pervasive. There are 8 16-bit registers, and the smallest addressable
unit of memory is a 16-bit word. There are only about 16 unique opcodes
in the 16-bit instruction, which means there's room for 2 6-bit
operands. With only 8 registers, a 6-bit operand can encode multiple
addressing modes (direct, indirect, offset, etc) and still have room for
small literal values.&lt;/p&gt;
&lt;p&gt;If you poke around github you'll find the start of a &lt;a href="https://github.com/krasin/llvm-dcpu16"&gt;llvm backend&lt;/a&gt; as
well as a &lt;a href="https://github.com/Wallbraker/DCPU-TCC"&gt;tcc&lt;/a&gt; port. I haven't looked into these compilers, but a C
ABI for the dcpu-16 would certainly be unusual to most developers. You
would likely have a 32-bit long, but char, short and int would all be 16
bits.&lt;/p&gt;
&lt;p&gt;As far as GNU tools go, a binutils port would be pretty straight
forward. I created a branch in &lt;a href="https://github.com/atgreen/moxiedev"&gt;moxiedev&lt;/a&gt; to try my hand at a dcpu-16
binutils port. It's not very well tested, but gas, ld, objdump, etc all
appear to work as advertised. All instructions with immediate operands,
whether literal values or computed by linker relocations, are encoded in
their long form. Taking advantage of the smaller encodings will require
linker relaxation work. It's not rocket science, but more work than the
couple of hours I was willing to put into it. There appears to be one
bug in GNU ld related to handling relocations for ELF targets where the
smallest addressable memory value is 16 bits vs 8. I worked around it by
making one small non-portable change to the target independent linker
code.&lt;/p&gt;
&lt;p&gt;I think GDB should be fairly straight forward as well. For most real
targets GDB will want to insert breakpoint instructions in the text of a
program, and it wants that instruction to be the same size as the
smallest instruction available on the target. Alas, the dcpu-16 has no
breakpoint instruction, 16-bit or othwerwise, so the simulator will have
to include special hardware breakpoint emulation logic. My suggestion is
to repurpose some of the 16-bit illegal instruction encodings. For
instance, the ISA allows for nonsensical instruction like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  SET 5, 6
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This means set the literal value 5 to 6. Setting a literal value makes
no sense, and the spec currently says that these instructions are
silently ignored. Rather than ignore them, you could use this class of
instruction as special software interrupt/breakpoint/trap instructions
like moxie's &lt;code&gt;swi&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A GCC port would be more challenging. It's definitely possible, but
would stretch GCC outside of its comfort zone. You'd end up excercising
bits of the compiler that aren't normally tested, and I imagine would
end up spending a lot of time debugging some of the darker recesses of
the compiler code. Best of luck to the brave soul who tries this!&lt;/p&gt;
&lt;p&gt;I'm very curious to see how this all plays out. Given the massive
success of Minecraft, I wouldn't be surprised if we see an app store for
in-game dcpu-16 based games. Good luck to Notch and the team at Mojang.&lt;/p&gt;</summary><category term="architecture"></category><category term="binutils"></category><category term="dcpu-16"></category><category term="gcc"></category><category term="gdb"></category></entry><entry><title>Using the Altera USB-Blaster on Fedora</title><link href="http://moxielogic.github.io/blog/using-the-altera-usb-blaster-on-fedora.html" rel="alternate"></link><published>2011-10-28T13:14:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-10-28:blog/using-the-altera-usb-blaster-on-fedora.html</id><summary type="html">&lt;p&gt;Altera's Quartus tools include some special software to download
bitstreams to their devices over USB (a DE-2 eval board, in my case).
They require some tricky work to set up properly on Fedora - my dev host
of choice. But you're in luck! I've packaged up an RPM that takes care
of this extra work for you. It creates a udev rule to set up the
USB-Blaster properly when you plug in your USB JTAG connection. It also
provides a service wrapper for Altera's jtagd daemon and moves some of
Altera's data files around so things just work. The sources are in
&lt;a href="http://github.com/atgreen/moxiedev" title="moxiedev"&gt;moxiedev&lt;/a&gt;, but I've posted the binary and source RPMs here for
convenience: &lt;a href="http://moxielogic.org/tools/"&gt;http://moxielogic.org/tools/&lt;/a&gt;. Be sure to read the docs in
&lt;code&gt;/usr/share/doc/moxie-quartus-altera-1&lt;/code&gt; once installed. It assumes that
you've already installed Quartus II on your box (they don't package in
RPM format, unfortunately).&lt;/p&gt;
&lt;p&gt;I'm told that the open source alternative &lt;a href="http://urjtag.org/" title="urjtag"&gt;UrJTAG&lt;/a&gt; may work for this
device as well, but I haven't had a chance to look into it. Any
experience worth sharing out there?&lt;/p&gt;</summary><category term="Altera"></category><category term="de2"></category><category term="JTAG"></category><category term="Quartus"></category></entry><entry><title>Fake RAM, load/store and push</title><link href="http://moxielogic.github.io/blog/fake-ram-loadstore-and-push.html" rel="alternate"></link><published>2011-10-11T19:00:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-10-11:blog/fake-ram-loadstore-and-push.html</id><summary type="html">&lt;p&gt;Progress report time....&lt;/p&gt;
&lt;p&gt;I need RAM in order to implement/test most instructions. To that end,
I've implemented a fake data cache that is always accessed within a
single cycle during the WRITE pipeline stage. Eventually this will have
to be replaced with a real data cache that reads/writes to real memory
over the wishbone bus while the processor pipeline stalls.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;push&lt;/code&gt; instruction was easy enough to implement. It's the first one
that writes to both memory and a register (to update the stack pointer).
This meant reworking the interface between the EXECUTE and WRITE stages.
&lt;code&gt;pop&lt;/code&gt; is a little more tricky because we need to update two registers:
the stack pointer and the register we're loading memory into. I'm going
to work this out tomorrow night, but I can see now how making it work in
a single cycle will require a little more logic than splitting it up
into two cycles. It will be interesting to experiment with changes like
that once everything is working.&lt;/p&gt;
&lt;p&gt;Also, I reorganized the HDL source to cleanly separate the moxie core
from the muskoka SoC and related firmwares and cores. As usual,
everything is in &lt;a href="http://github.com/atgreen/moxiedev" title="moxiedev"&gt;github&lt;/a&gt;.&lt;/p&gt;</summary><category term="muskoka"></category><category term="SoC"></category><category term="wishbone"></category></entry><entry><title>GTKWave Tip #2: Translate Filter Files</title><link href="http://moxielogic.github.io/blog/gtkwave-tip-2-translate-filter-files.html" rel="alternate"></link><published>2011-10-06T17:10:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-10-06:blog/gtkwave-tip-2-translate-filter-files.html</id><summary type="html">&lt;p&gt;Tip #1 was about using an external process to perform dynamic
translations of signal display values. GTKWave can also perform simple
static translations of data. In the example below, for instance, moxie's
execute unit is receiving a 4-bit signal identifying "register A"
(riA_i) for whatever operation is about to happen. This waveform would
normally just show "0", "1", "2", etc. We can replace those values by
using a simple filter file that maps those string representations to
alternate values. Here's the one I use for register names:
&lt;a href="https://github.com/atgreen/moxiedev/blob/master/moxie/soc/muskoka/gtkwave/gtkwave-regs.txt"&gt;gtkwave-regs.txt&lt;/a&gt;. After applying the filter we see the register name
"$r1" instead of its register file index value of "2".. a tremendous
readability improvement!&lt;br /&gt;
&lt;center&gt;
&lt;img alt="gtkwave with moxie register name translation filter file" src="http://moxielogic.org/blog/wp-content/uploads/2011/10/Screenshot-GTKWave-dump.vcd-1.png" title="Screenshot-GTKWave - dump.vcd-1" /&gt;
&lt;/center&gt;&lt;/p&gt;</summary><category term="gtkwave"></category></entry><entry><title>GTKWave Tip #1</title><link href="http://moxielogic.github.io/blog/gtkwave-tip-1.html" rel="alternate"></link><published>2011-10-04T10:34:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-10-04:blog/gtkwave-tip-1.html</id><summary type="html">&lt;p&gt;GTKWave is a new tool for me, so I'll use this space to post useful tips
as I discover them.&lt;/p&gt;
&lt;p&gt;The first tip comes from Tony Bybell, author of &lt;a href="http://gtkwave.sourceforge.net" title="GTKWave"&gt;GTKWave&lt;/a&gt;, who pointed
me at some helpful functionality in a recent &lt;a href="http://moxielogic.org/blog/?p=511" title="blog comment"&gt;blog comment&lt;/a&gt;. You can
enhance GTKWave's waveform display by replacing the normal data
presentation with something of your own design. So, for instance,
instead of looking at an opcode of "8033", you can see the disassenbled
moxie instruction &lt;code&gt;inc $fp 3&lt;/code&gt;. You do this by implementing a program
that reads raw values from stdin and writes translations to stdout, and
then attaching this program as a filter to one of your signals.&lt;/p&gt;
&lt;p&gt;I wrote a quick moxie disassembler in lisp (&lt;a href="https://github.com/atgreen/moxiedev/blob/master/moxie/soc/muskoka/gtkwave/gtkwave-opcodes.lisp"&gt;gtkwave-opcodes.lisp&lt;/a&gt;),
and it is proving to be very handy!&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://moxielogic.org/images/Screenshot-GTKWave-dump.vcd_.png"&gt;&lt;img alt="gtkwave with moxie disassembly" src="http://moxielogic.org/images/Screenshot-GTKWave-dump.vcd_-300x117.png" /&gt;&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;</summary><category term="gtkwave"></category><category term="lisp"></category></entry><entry><title>Branch delays</title><link href="http://moxielogic.github.io/blog/branch-delays.html" rel="alternate"></link><published>2011-09-28T07:13:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-09-28:blog/branch-delays.html</id><summary type="html">&lt;p&gt;I've coded up logic for more arithmetic instructions, register moves, as
well as direct and indirect jumps. For jumps, I simply pass a branch
signal from the execute stage back to the fetch stage, as well as the
computed target address. Here's some code that works now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;.text&lt;/span&gt;
    &lt;span class="nf"&gt;xor&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt; &lt;span class="c"&gt;# Zero out $r0&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;$r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;$r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;$r3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;$r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;
&lt;span class="nl"&gt;loop:&lt;/span&gt;   &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt; &lt;span class="c"&gt;# Increment $r0&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt; 
    &lt;span class="no"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt; 
    &lt;span class="no"&gt;jmpa&lt;/span&gt;    &lt;span class="no"&gt;loop&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;0x1000&lt;/span&gt; &lt;span class="c"&gt;# Offset hack&lt;/span&gt;
    &lt;span class="nf"&gt;nop&lt;/span&gt;
    &lt;span class="nf"&gt;nop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A couple of things to note... Boot ROM is mapped into the address space
at 0x1000, which explains the offset hack above. A linker script is
probably the right way to do this. Using ".org 0x1000" at the start of
the source appears to pad the resulting object with 0x1000 bytes of
nothing, which means it doesn't fit into the small space I've allocated
for bootrom.&lt;/p&gt;
&lt;p&gt;Also note that I've got to deal with branch delay slots. I'm not exactly
sure what I want to do yet. Due to the nature of the variable width
instruction encoding, it looks like you can have either 1 or 2 delay
slots to fill, depending on the instruction sizes. I don't like this at
all. I'll probably end up limiting it to one delay slot.&lt;/p&gt;
&lt;p&gt;This is one of those ugly areas where implementation informs design. I'd
rather not have delay slots at all, but it's hard to ignore the
performance gain.&lt;/p&gt;</summary><category term="architecture"></category><category term="gas"></category><category term="verilog"></category></entry><entry><title>A simulation milestone for the Muskoka SoC!</title><link href="http://moxielogic.github.io/blog/a-simulation-milestone-for-the-muskoka-soc.html" rel="alternate"></link><published>2011-09-27T19:47:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-09-27:blog/a-simulation-milestone-for-the-muskoka-soc.html</id><summary type="html">&lt;p&gt;A moxie-based SoC had it's first successful simulation run today....&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="gtkwave display of first code run" src="http://moxielogic.org/blog/wp-content/uploads/2011/09/gtkwave20110927-300x204.png" /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Pretty exciting! So, here's what's happening...&lt;/p&gt;
&lt;p&gt;The SoC, code named "Muskoka", has three main components: the moxie
core, a wishbone switch and a ROM device. The switch was easy to
implement, as I just have a single bus master (moxie), and a single
slave device (bootrom) for now. The boot ROM is populated with bits
generated by assembling the code below like so:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;moxie-elf-as -o bootrom.x bootrom.s     moxie-elf-objcopy -O verilog bootrom.x bootrom.vh&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;.text&lt;/span&gt;
    &lt;span class="nf"&gt;xor&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;  &lt;span class="c"&gt;# Zero out $r0&lt;/span&gt;
    &lt;span class="nf"&gt;xor&lt;/span&gt; &lt;span class="no"&gt;$r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r1&lt;/span&gt;
    &lt;span class="nf"&gt;xor&lt;/span&gt; &lt;span class="no"&gt;$r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r2&lt;/span&gt;
    &lt;span class="nf"&gt;xor&lt;/span&gt; &lt;span class="no"&gt;$r3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r3&lt;/span&gt;
    &lt;span class="nf"&gt;xor&lt;/span&gt; &lt;span class="no"&gt;$r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;$r4&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;  &lt;span class="c"&gt;# Increment $r0 by 1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
    &lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="no"&gt;$r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0x1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The moxie core itself is has 4 pipeline stages: Fetch, Decode, Execute
and Write. The Fetch stage is probably the most complicated at this
point. Remember that moxie has both 16- and 48-bit instructions.
However, we're fetching instruction memory from the ROM device 32-bits
at a time. The fetch logic feeds these 32-bits into an instruction queue
and pulls out the right number of bits at the other end, depending on
the instruction about to be decoded.&lt;/p&gt;
&lt;p&gt;So far only NOP, XOR and INC have been implemented, and there's no
pipeline hazard detection logic, but careful analysis of the simulation
dumps in gtkwave show that everything is finally starting to work. Baby
steps...&lt;/p&gt;
&lt;p&gt;As usual, everything has been committed to &lt;a href="http://github.com/atgreen/moxiedev" title="moxiedev"&gt;moxiedev&lt;/a&gt; on github.&lt;/p&gt;</summary><category term="architecture"></category><category term="muskoka"></category><category term="SoC"></category><category term="verilog"></category><category term="wishbone"></category></entry><entry><title>RTEMS status update</title><link href="http://moxielogic.github.io/blog/rtems-status-update.html" rel="alternate"></link><published>2011-06-15T04:35:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-06-15:blog/rtems-status-update.html</id><summary type="html">&lt;p&gt;The &lt;a href="http://www.rtems.com"&gt;RTEMS&lt;/a&gt; port in &lt;a href="http://www.moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt; is looking pretty good right now.
Here's a test of the RTEMS network loopback device running on the moxie
gdb simulator.  The first two client connections fail in this test. 
It's supposed to fail in the first case, but I'm not sure about the
second case.   It's possible that this is just a result of there being
no pre-emptive context switching in the gdb simulator (no timers!).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;moxie-elf-run loopback.exe
&lt;span class="s2"&gt;&amp;quot;Network&amp;quot;&lt;/span&gt; initializing!
&lt;span class="s2"&gt;&amp;quot;Network&amp;quot;&lt;/span&gt; initialized!
Try running client with no server present.
Should fail with &lt;span class="sb"&gt;`&lt;/span&gt;connection refused&lt;span class="s1"&gt;&amp;#39;.&lt;/span&gt;
&lt;span class="s1"&gt;Connect to server.&lt;/span&gt;
&lt;span class="s1"&gt;Can&amp;#39;&lt;/span&gt;t connect to server: Connection refused
Client closing connection.

Start server.

Try running client with server present.
Connect to server.
Can&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;t connect to server: Connection refused
Client closing connection.
Client task terminating.
Create socket.
Bind socket.

Try running two clients.
Connect to server.
Connect to server.
ACCEPTED:7F000001
ACCEPTED:7F000001
Write 22-byte message to server.
Write 22-byte message to server.
Read &lt;span class="m"&gt;43&lt;/span&gt; from server: Server received &lt;span class="m"&gt;22&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Hi there, server &lt;span class="o"&gt;(&lt;/span&gt;3&lt;span class="o"&gt;)&lt;/span&gt;.&lt;span class="o"&gt;)&lt;/span&gt;
Read &lt;span class="m"&gt;43&lt;/span&gt; from server: Server received &lt;span class="m"&gt;22&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Hi there, server &lt;span class="o"&gt;(&lt;/span&gt;2&lt;span class="o"&gt;)&lt;/span&gt;.&lt;span class="o"&gt;)&lt;/span&gt;
Client closing connection.
Client task terminating.
Client closing connection.
Client task terminating.
Worker task terminating.
Worker task terminating.

Try running three clients.
Connect to server.
Connect to server.
Connect to server.
ACCEPTED:7F000001
ACCEPTED:7F000001
ACCEPTED:7F000001
Write 22-byte message to server.
Write 22-byte message to server.
Write 22-byte message to server.
Read &lt;span class="m"&gt;43&lt;/span&gt; from server: Server received &lt;span class="m"&gt;22&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Hi there, server &lt;span class="o"&gt;(&lt;/span&gt;5&lt;span class="o"&gt;)&lt;/span&gt;.&lt;span class="o"&gt;)&lt;/span&gt;
Read &lt;span class="m"&gt;43&lt;/span&gt; from server: Server received &lt;span class="m"&gt;22&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Hi there, server &lt;span class="o"&gt;(&lt;/span&gt;6&lt;span class="o"&gt;)&lt;/span&gt;.&lt;span class="o"&gt;)&lt;/span&gt;
Read &lt;span class="m"&gt;43&lt;/span&gt; from server: Server received &lt;span class="m"&gt;22&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Hi there, server &lt;span class="o"&gt;(&lt;/span&gt;4&lt;span class="o"&gt;)&lt;/span&gt;.&lt;span class="o"&gt;)&lt;/span&gt;
Client closing connection.
Client task terminating.
Client closing connection.
Client task terminating.
Client closing connection.
Client task terminating.
Worker task terminating.
Worker task terminating.
Worker task terminating.
*** END OF LOOPBACK TEST ***
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This really needs to be tested on qemu, but I think it's time to get
back into verilog.&lt;/p&gt;</summary><category term="RTEMS"></category></entry><entry><title>Bisecting GCC</title><link href="http://moxielogic.github.io/blog/bisecting-gcc.html" rel="alternate"></link><published>2011-06-06T07:23:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2011-06-06:blog/bisecting-gcc.html</id><summary type="html">&lt;p&gt;The thing about &lt;a href="http://gcc.gnu.org"&gt;GCC&lt;/a&gt; is that things break when you take your eye off
the ball. And this is what happened during my months long hiatus from
the moxie project. Somewhere between early March and today, the moxie
GCC port lost the ability to compile non-trivial code, notably libgcc.
Firing up gdb on a core file may have been illuminating to somebody who
lived in GCC sources every day but, to the occasional hacker, it's
difficult to see where things went wrong if you don't know what you're
looking for. Enter &lt;a href="http://www.kernel.org/pub/software/scm/git/docs/git-bisect.html"&gt;git bisect&lt;/a&gt;...&lt;/p&gt;
&lt;p&gt;The git bisect tool automates finger pointing by binary searching
through your source history for offending patches. It needs three things
to work:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;An older known working version of the sources.&lt;/li&gt;
&lt;li&gt;A newer known broken version of the sources.&lt;/li&gt;
&lt;li&gt;A test executable (typically a shell script) that will tell whether
    a given version of the source code is broken or not.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Given all this, git bisect will start a binary search through the git
history for your code, looking for the exact commit that caused the test
to fail.&lt;/p&gt;
&lt;p&gt;The test case I used was to build moxie's C compiler and try to compile
one of the libgcc sources that fails. If the compiler doesn't report an
error, we're good, otherwise we know we still have the bug. Here's the
script I used as the git bisect test:  &lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="c"&gt;# My git clone of the gcc tree&lt;/span&gt;
&lt;span class="nv"&gt;GCCSRC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;~/bisect/gcc

&lt;span class="c"&gt;# My pre-processed test case&lt;/span&gt;
&lt;span class="nv"&gt;TESTSRC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;~/bisect/test.i

&lt;span class="nb"&gt;cd&lt;/span&gt; ~/bisect

rm -rf build
mkdir build

&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;build&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="nv"&gt;$GCCSRC&lt;/span&gt;/configure --target&lt;span class="o"&gt;=&lt;/span&gt;moxie-elf --enable-languages&lt;span class="o"&gt;=&lt;/span&gt;c&lt;span class="p"&gt;;&lt;/span&gt;
 make -j8 all-gcc&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;test&lt;/span&gt; -f build/gcc/cc1&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="c"&gt;# build my test case&lt;/span&gt;
  build/gcc/cc1 -O2 &lt;span class="nv"&gt;$TESTSRC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="c"&gt;# cc1 returns exit codes outside of git&amp;#39;s acceptable range, so...&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;test&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$?&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; -ne &lt;span class="s2"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;exit &lt;/span&gt;1&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;fi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nb"&gt;exit &lt;/span&gt;0&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;exit &lt;/span&gt;1&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Note that GCC is maintained in a &lt;a href="http://gcc.gnu.org/svn.html"&gt;subversion tree&lt;/a&gt;, but there's an
official &lt;a href="http://gcc.gnu.org/wiki/GitMirror"&gt;git mirror&lt;/a&gt; that makes all of this possible. You need to
clone it locally before you can do anything.&lt;/p&gt;
&lt;p&gt;There were over 1000 commits between my last known working version and
today's GCC sources. My first thought was... "this is going to take
hours". I was wrong.&lt;/p&gt;
&lt;p&gt;Running "&lt;code&gt;git bisect run ~/bisect/test.sh&lt;/code&gt;" took all of 35 minutes.&lt;/p&gt;
&lt;p&gt;The smartest thing I did here was work on a &lt;a href="http://aws.amazon.com/ec2/instance-types/"&gt;large amazon ec2
instance&lt;/a&gt;. It's a cloud-hosted virtual server similar to a dual-core
system with 7GB RAM and ample fast storage all for about 34 cents an
hour. I've taken to doing development in the cloud and, relative to my
standard setup, it is blazingly fast! I created a Fedora 15 image, yum
installed all my tools (don't forget &lt;a href="http://ccache.samba.org/"&gt;ccache&lt;/a&gt;!), git cloned
&lt;a href="http://github.com/atgreen/moxiedev"&gt;moxiedev&lt;/a&gt;, gcc and my &lt;a href="http://github.com/atgreen/emacs"&gt;emacs config&lt;/a&gt; files, and I was bisecting in
no time.&lt;/p&gt;
&lt;p&gt;Git bisect told me that on Monday, March 21, my old colleague Richard
Sandiford committed some &lt;a href="http://gcc.gnu.org/ml/gcc-patches/2011-03/msg01344.html"&gt;improvements to GCC&lt;/a&gt; that were tripping up
the moxie port. A few minutes later I caught up with Richard on &lt;a href="http://gcc.gnu.org/wiki/GCConIRC"&gt;IRC&lt;/a&gt;,
where he explained the patch to me. Shortly after this I'm testing a
fix. Amazing.&lt;/p&gt;</summary><category term="ec2"></category><category term="gcc"></category><category term="git"></category></entry><entry><title>On-chip communications</title><link href="http://moxielogic.github.io/blog/on-chip-communications.html" rel="alternate"></link><published>2010-10-06T04:37:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-10-06:blog/on-chip-communications.html</id><summary type="html">&lt;p&gt;I need to build real SoC infrastructure around my developing core in
order to test it on real hardware. For the most part, this means a
memory controller and IO devices. I've decided to implement a shared-bus
wishbone-style interconnect for these devices. &lt;a href="http://en.wikipedia.org/wiki/Wishbone_%28computer_bus%29"&gt;Wishbone&lt;/a&gt; is an open
source on chip bus architecture that is popular with many open core
developers. While not perfect, wishbone is a good choice for this first
SoC due its simplicity and the ample supply of sample implementations.&lt;/p&gt;
&lt;p&gt;The main complaints about wishbone are the lack of efficient semaphore
operations (the bus remains locked for an entire read/modify/write
operation) and the lack of pipelined reads/writes. This doesn't bother
me for the moment. I just need a simple interconnect so I can focus on
debugging the moxie core part of the SoC.&lt;/p&gt;
&lt;p&gt;By the way, there's a terrific book on this subject called "On-Chip
Communication Architectures". Chapters 2 and 3 are great introductions
to on-chip interconnects, and it looks like Google Books has the entire
chapter 2 online here...&lt;/p&gt;
&lt;iframe frameborder="0" scrolling="no" style="border:0px" src="http://books.google.ca/books?id=uR3Vw9mYtpIC&amp;amp;lpg=PP1&amp;amp;ots=ZBpqbO_QDG&amp;amp;dq=On-Chip%20Communication%20Architectures&amp;amp;pg=PA145&amp;amp;output=embed" width="500" height="500"&gt;&lt;/iframe&gt;</summary><category term="architecture"></category><category term="SoC"></category><category term="wishbone"></category></entry><entry><title>Quartus II and the Cloud: Not There Yet...</title><link href="http://moxielogic.github.io/blog/quartus-ii-and-the-cloud-not-there-yet.html" rel="alternate"></link><published>2010-09-20T15:55:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-09-20:blog/quartus-ii-and-the-cloud-not-there-yet.html</id><summary type="html">&lt;p&gt;Altera's &lt;a href="http://www.altera.com/products/software/quartus-ii/web-edition/qts-we-index.html"&gt;Quartus II&lt;/a&gt; software is now running on my Fedora box, but I
was really hoping to load it into a grid of &lt;a href="http://aws.amazon.com/ec2/"&gt;Amazon EC2 instances&lt;/a&gt; so
I could batch out jobs for synthesis, place and route. Unfortunately the
free-beer Quartus software requires a license file that is generated
based on your MAC address. Bah! Amazon doesn't provide persistent MAC
addresses AFAICT.&lt;/p&gt;
&lt;p&gt;Are they trying to prevent this kind of use, or are they just behind the
times? Altera - please make your software cloud ready! I'd really like
to try out &lt;a href="http://www.redhat.com/docs/en-US/Red_Hat_Enterprise_MRG/1.1/html/Grid_User_Guide/sect-Grid_User_Guide-Cloud_Computing-EC2E.html"&gt;condor's ec2 support&lt;/a&gt; to speed up this kind of work.&lt;/p&gt;
&lt;p&gt;It's a shame that there are no credible Free Software alternatives to
these tools.&lt;/p&gt;
&lt;p&gt;Maybe there's some way to make this work. Please comment below if you
have the clue that I'm missing...&lt;/p&gt;</summary><category term="Altera"></category><category term="cloud"></category></entry><entry><title>Pipeline hazards</title><link href="http://moxielogic.github.io/blog/pipeline-hazards.html" rel="alternate"></link><published>2010-09-10T13:25:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-09-10:blog/pipeline-hazards.html</id><summary type="html">&lt;p&gt;I've coded up a first go at four pipeline stages so far: &lt;a href="http://github.com/atgreen/moxiedev/blob/master/moxie/rtl/verilog/cpu_fetch.v"&gt;Fetch&lt;/a&gt;,
&lt;a href="http://github.com/atgreen/moxiedev/blob/master/moxie/rtl/verilog/cpu_decode.v"&gt;Decode&lt;/a&gt;, &lt;a href="http://github.com/atgreen/moxiedev/blob/master/moxie/rtl/verilog/cpu_execute.v"&gt;Execute&lt;/a&gt;, and Write. After the relative complexity of the
&lt;a href="http://moxielogic.org/blog/?p=444"&gt;Fetch implementation&lt;/a&gt;, the rest has been pretty straight forward, and
I've started running the first bit of compiled code through the pipline.
Here's that start of our Hello World C application. It's &lt;code&gt;__start&lt;/code&gt; from
crt0.o:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;00001000 &amp;lt;__start&amp;gt;:&lt;/span&gt;
&lt;span class="x"&gt;    1000:       01 10 00 40     ldi.l    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;sp&lt;/span&gt;&lt;span class="x"&gt;, 0x400000&lt;/span&gt;
&lt;span class="x"&gt;    1004:       00 00&lt;/span&gt;
&lt;span class="x"&gt;    1006:       01 00 00 00     ldi.l    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;fp&lt;/span&gt;&lt;span class="x"&gt;, 0x0&lt;/span&gt;
&lt;span class="x"&gt;    100a:       00 00&lt;/span&gt;
&lt;span class="x"&gt;    100c:       91 0c           dec      &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;sp&lt;/span&gt;&lt;span class="x"&gt;, 0xc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This code simply initializes the stack and frame pointers, and makes
room for a new stack frame (just ignore the obvious inefficiencies for
now!).&lt;/p&gt;
&lt;p&gt;Running this through the pipline, I can see the first &lt;code&gt;ldi.l&lt;/code&gt; make it's
way through Fetch, Decode, Execute (basically nothing) and Write. The
second &lt;code&gt;ldi.l&lt;/code&gt; works similarly. Then we get to the &lt;code&gt;dec&lt;/code&gt;. In order to
decrement, we need to read the $sp from the register file in Decode,
perform the subtraction in Execute, and save it back to the register
file in Write. But when I first ran it through the &lt;a href="http://www.icarus.com/eda/verilog/"&gt;verilog simulator&lt;/a&gt;
I saw the &lt;code&gt;dec&lt;/code&gt; instruction reading &lt;code&gt;0x00000000&lt;/code&gt; from $sp instead of
&lt;code&gt;0x400000&lt;/code&gt;. I'm only three instructions into my first simulation and
I've hit my first pipeline hazard! The &lt;code&gt;0x400000&lt;/code&gt; from the first
instruction hasn't been written to $sp yet, as we're just about to
start the Write stage for that instruction!&lt;/p&gt;
&lt;p&gt;So the next step is to add a little hazard detection to the pipeline
control logic. I'm going to stick with &lt;a href="http://homepage3.nifty.com/alpha-1/computer/Interlock_E.html"&gt;pipeline interlocks&lt;/a&gt; for now
(stuffing NOPs in the middle of the pipeline) instead of more
complicated &lt;a href="http://en.wikipedia.org/wiki/Hazard_%28computer_architecture%29#Register_forwarding"&gt;forwarding logic&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As usual, &lt;a href="http://github.com/atgreen/moxiedev"&gt;everything is in moxiedev&lt;/a&gt;. Just "cd
moxiedev/moxie/rtl/verilog &amp;amp;&amp;amp; make &amp;amp;&amp;amp; ./a.out" to run the simulation.&lt;/p&gt;</summary><category term="architecture"></category><category term="verilog"></category></entry><entry><title>Fetching instructions</title><link href="http://moxielogic.github.io/blog/fetching-instructions.html" rel="alternate"></link><published>2010-09-07T13:56:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-09-07:blog/fetching-instructions.html</id><summary type="html">&lt;p&gt;Moxie requires some interesting instruction fetch logic.&lt;/p&gt;
&lt;p&gt;For my initial implementation I'm assuming a 32-bit path to instruction
memory. But moxie has both 16- and 48-bit instructions, so it's not like
simple RISC cores that can feed the pipeline on every cycle. My solution
is to feed 32-bit instruction memory words into a Instruction FIFO. 16-
and 48-bit instructions pop out of the other end of the FIFO on every
cycle (or a NOP bubble when we're waiting for the last 16 bits of a
48-bit instruction). My initial Instruction FIFO is 64-bits long. From
my simple testing it looks like this does a reasonable job of keeping
the instruction memory path busy, and issuing instructions as often as
possible (I'm just eyeballing the gtkwave output, reproduced below). I
can experiment with a longer Instruction FIFO later.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://moxielogic.org/blog/wp-content/uploads/2010/09/fetch.png" title="waves from the moxie Instruction FIFO " /&gt;&lt;/p&gt;
&lt;p&gt;This image shows a few signals from the Instruction FIFO. valid_o tells
us that we're popping off a valid instruction from the FIFO, whereas
full_o tells us not to write any data to the FIFO because it's full. So
far, so good - decoupling the fetching of instruction memory from the
rest of the pipeline is obviously the right thing to do.&lt;/p&gt;
&lt;p&gt;One more complication that I'm going to punt on for now is PC tracking.
Eventually we'll want to pass the PC down the pipeline so we get
accurate exception addresses. Tracking the PC through the Instruction
FIFO is just one more little complication that I'll tackle after I make
more progress on the rest of the microarchitecture.&lt;/p&gt;
&lt;p&gt;I've only done some behavioral simulation so far, but I believe the code
is synthesizable. The code is in github here: &lt;a href="http://bit.ly/9yVQ7U"&gt;http://bit.ly/9yVQ7U&lt;/a&gt;.
Running make should build everything, then just run "a.out".&lt;/p&gt;
&lt;p&gt;Note that I'm using magic instruction memory: an array populated with a
hello world app built like so...  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ moxie-elf-gcc -o hello.x -O2 hello.c -Tsim.ld $ moxie-elf-objcopy -O verilog hello.x hello.vh&lt;/code&gt;&lt;br /&gt;
And the verilog simulator reads hello.vh directly. Pretty cool!&lt;/p&gt;
&lt;p&gt;(I just realized I wrote about fetching instructions &lt;a href="http://moxielogic.org/blog/?p=161"&gt;almost 18 months
ago&lt;/a&gt; - that took too long!)&lt;/p&gt;</summary><category term="architecture"></category><category term="verilog"></category></entry><entry><title>The FPGA test board</title><link href="http://moxielogic.github.io/blog/the-fpga-test-board.html" rel="alternate"></link><published>2010-08-18T14:03:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-08-18:blog/the-fpga-test-board.html</id><summary type="html">&lt;p&gt;I picked up a lightly used FPGA development board from craigslist today.
It's the &lt;a href="http://www.altera.com/education/univ/materials/boards/unv-de2-board.html"&gt;Altera DE2&lt;/a&gt; board with a Cyclone II FPGA.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="&amp;quot;The DE2\'s Cyclone II &amp;quot;" src="http://moxielogic.org/blog/wp-content/uploads/2010/08/P1230549-300x225.jpg" /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;There are a few nice things about this board...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It's loaded with real and useful peripherals: 16x2 LCD Panel, VGA
    DAC, lots of LEDs, RS232, IrDA, PS/2, USB, 100/10Mbs Ethernet, audio
    codec, NTSC TV decoder, SD card connector, etc, etc. This means I
    can focus on the moxie microarchitecture, and not worry about
    building a full feature rich SoC.&lt;/li&gt;
&lt;li&gt;Altera's Quartus II software runs on Linux&lt;/li&gt;
&lt;li&gt;It was relatively cheap - \$200&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When I got home I was happy to discover that the board actually powers
on and the appropriate LEDs blink. You can never be sure with used
hardware!&lt;/p&gt;
&lt;p&gt;As for the Quartus software... I'm running Fedora 13 x86-64. This isn't
a supported OS for them but I'm hoping it will work since they do
support RHEL5. Quartus appears to be a 32-bit binary, so I had to go
through a tedious process of installing missing 32-bit libraries -
something that could have been avoided if they would simply package this
thing in an RPM. The good news is that after installing the appropriate
libraries, it does appear to start up.&lt;/p&gt;
&lt;p&gt;More as it happens...&lt;/p&gt;</summary><category term="de2"></category><category term="fpga"></category></entry><entry><title>Still hacking...</title><link href="http://moxielogic.github.io/blog/still-hacking.html" rel="alternate"></link><published>2010-05-11T06:45:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2010-05-11:blog/still-hacking.html</id><summary type="html">&lt;p&gt;...Just in case you were wondering!&lt;/p&gt;
&lt;p&gt;But it's been slow going. The good news is that moxie is front and
centre for me again, so let's see what we can do over the next few
weeks. And over these next few weeks I'm promising myself not to touch a
C compiler until the moxie HDL code starts executing a few instructions.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://moxielogic.org/images/yos.jpg"&gt;&lt;img alt="Half Dome at Yosemite" src="http://moxielogic.org/images/yos-300x225.jpg" /&gt;&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;In other news, I visited one of my favourite places this past weekend.
Yosemite is a great place to reset. &lt;a href="http://www.nps.gov/yose/"&gt;Go there&lt;/a&gt;!&lt;/p&gt;</summary></entry><entry><title>The Moxielyzer</title><link href="http://moxielogic.github.io/blog/the-moxielyzer.html" rel="alternate"></link><published>2009-10-14T22:05:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-10-14:blog/the-moxielyzer.html</id><summary type="html">&lt;p&gt;I just committed a little binary analysis tool to &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt;. You can
use it to perform simple static analysis on moxie binaries. The kinds of
things I'm looking for are compiler bugs (because I know there's still
one there that is triggered by -frerun-cse-after-loop), and instruction
statistics. For instance, which registers are used as load offsets, and
how often? The tool uses a primitive plugin architecture that should
make it easy to add new analysis tools in the future. It's called the
moxielyzer, and here is the &lt;a href="http://github.com/atgreen/moxiedev/commit/150f230a2f4a2084e277b89dde846ca02f9ccc12"&gt;initial commit&lt;/a&gt;. Run it with no arguments
to get a list of plugins. Run it with just a plugin name, and it will
describe the plugin. Run it with a plugin name as well as an ELF moxie
executable filename, and the analysis will be performed.&lt;/p&gt;
&lt;p&gt;I had written a similar tool for ggx back in the bad old days. Another
option was to hack this stuff into gas, but I prefer to keep gas "clean"
(translation: I want the freedom to maintain hacky analysis code).&lt;/p&gt;
&lt;p&gt;BTW - I'm also rolling out a new &lt;a href="http://sourceware.org/libffi/"&gt;libffi&lt;/a&gt; in a few weeks. You can keep
track of the release candidate test results &lt;a href="http://moxielogic.org/wiki/index.php?title=Libffi_3.0.9"&gt;on the wiki here&lt;/a&gt;.&lt;/p&gt;</summary><category term="architecture"></category><category term="moxielyzer"></category></entry><entry><title>Summer is over, so put away the white pants and start submitting patches!</title><link href="http://moxielogic.github.io/blog/summer-is-over-so-put-away-the-white-pants-and-start-submitting-patches.html" rel="alternate"></link><published>2009-09-10T14:21:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-09-10:blog/summer-is-over-so-put-away-the-white-pants-and-start-submitting-patches.html</id><summary type="html">&lt;p&gt;It's been a while since my last update. What can I say... summer was
nice.&lt;/p&gt;
&lt;p&gt;But now, back to business! I've just committed some long overdue patches
to the upstream GNU tools:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://sourceware.org/ml/gdb-patches/2009-09/msg00289.html"&gt;Add a device tree blob to the gdb simulator&lt;/a&gt;. This lets us
    describe the gdb sim target to our single kernel image as described
    in &lt;a href="http://moxielogic.org/blog/?p=310"&gt;this posting&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A GCC size optimization. Load 0 into a register &lt;a href="http://gcc.gnu.org/ml/gcc-patches/2009-09/msg00651.html"&gt;via xor&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Improve function prologue &lt;a href="http://gcc.gnu.org/ml/gcc-patches/2009-09/msg00652.html"&gt;code generation&lt;/a&gt;, and a corresponding
    &lt;a href="http://sourceware.org/ml/gdb-patches/2009-09/msg00287.html"&gt;gdb change&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://gcc.gnu.org/ml/gcc-patches/2009-09/msg00653.html"&gt;Use 6 registers to pass function arguments&lt;/a&gt; as [described
    here][].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This gets us to booting the kernel, loading BusyBox, running some shell
code and... crashing on the first fork. No problemo. Nothing a small
matter of programming can't fix. However, there are some other
distractions...&lt;/p&gt;
&lt;p&gt;Verilog is lots of fun! It looks like regular programming, but it feels
more like building a kinetic sculpture.&lt;/p&gt;
&lt;p&gt;There's also the small matter of not having an interrupt controller! So
there's some work here to design an interrupt controller, implement it
in verilog, simulate it qemu (and possibly the gdb sim), and port the
kernel over to using it. This should be interesting...&lt;/p&gt;</summary><category term="gcc"></category><category term="gdb"></category><category term="linux"></category><category term="qemu"></category><category term="verilog"></category></entry><entry><title>More hello world progress with uClibc/uClinux, and a GDB question.</title><link href="http://moxielogic.github.io/blog/more-hello-world-progress-with-uclibcuclinux-and-a-gdb-question.html" rel="alternate"></link><published>2009-08-18T21:49:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-08-18:blog/more-hello-world-progress-with-uclibcuclinux-and-a-gdb-question.html</id><summary type="html">&lt;p&gt;Tonight I got a hello world app to use uClibc's &lt;code&gt;puts()&lt;/code&gt; routine! This
is a big deal because it's the first time I've had system calls coming
in from userland. I haven't checked the changes in yet, because they're
a mess, but here's a basic run-down of what I had to do...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, uClibc had to be taught how to make system calls to the moxie
    uClinux kernel. This was straight forward, except I came across one
    surprise which I'll describe below.&lt;/li&gt;
&lt;li&gt;Next, I needed to add more files to my initfs. Specifically, I
    needed a /dev/console. Fortunately, the kernel build process makes
    this easy. I decided to use the "text file" approach to populating
    the initramfs as described in &lt;a href="http://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt"&gt;this document&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Finally, I had to create a tty device for my default console that
    spoke through the gdb simulator via software interrupts. Fortunately
    the ia64 port had a similar tty device for talking through one of
    HP's simulators that I was able to mostly copy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once all this was done, I was able to build a standard Hello World app
with moxie-uclinux-gcc, and it just worked!&lt;/p&gt;
&lt;p&gt;What about the system call surprise? Despite what I read somewhere that
said that Linux system calls had a maximum of 5 parameters -- that's not
quite true. Some take 6 (are there any with 7? more?). This thwarted my
attempt to get busybox running tonight, because it uses mmap, and mmap
is one of those 6-argument system calls. There are a few ways to fix
this. I think I'll just hack the compiler to use 6 register arguments
and see what that does to code size/performance.&lt;/p&gt;
&lt;p&gt;If there are any GDB hackers reading this... I have one question for
you... The kernel is loading and relocating my "init" program, then
execve'ing it. When I run the kernel in gdb, it would be nice for gdb to
load the debug info for init so I could see what it's doing when I step
into userland. Is there some way to do this manually?&lt;/p&gt;</summary><category term="gdb"></category><category term="linux"></category></entry><entry><title>First moxie-linux userland app runs!</title><link href="http://moxielogic.github.io/blog/first-moxie-linux-userland-app-runs.html" rel="alternate"></link><published>2009-08-17T20:11:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-08-17:blog/first-moxie-linux-userland-app-runs.html</id><summary type="html">&lt;p&gt;I've been taking advantage of the nice summer weather recently, so it's
taken me a while to get around to this... but here's the first moxie
userland app!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#define MSG &amp;quot;Hello, World!\n&amp;quot;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;noinline&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;gloss_write&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;asm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;swi 5&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;write&amp;quot; via the gdb simulator&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;gloss_write&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MSG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MSG&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you build this with moxie-uclinux-gcc, name it &lt;code&gt;init&lt;/code&gt; and
point the linux kernel build machinery at it, you'll get a kernel that
boots, loads the &lt;code&gt;init&lt;/code&gt; BFLT binary from a ramfs, and performs an
&lt;code&gt;execve&lt;/code&gt; system call on it! The program loops forever, printing "Hello,
World!" via the gdb simulator IO interrupt because I haven't fixed up
uClibc to perform system calls yet. Baby steps, my friends! Baby steps!
We will get there!&lt;/p&gt;
&lt;p&gt;The main bit of work needed to get this going was to fix up the software
interrupt handler for system calls. I'm saving registers in a &lt;code&gt;pt_regs&lt;/code&gt;
struct just prior to calling the &lt;code&gt;execve&lt;/code&gt; system call. &lt;code&gt;execve&lt;/code&gt; then
manipulates these saved registers so we end up running the newly exec'd
program when we "return" from the system call. This was all done in
&lt;a href="http://github.com/atgreen/moxiedev/blob/4b1f3184f4a73347008c845d25e3f968f2afc569/linux-2.6/arch/moxie/kernel/exception_handler.S"&gt;linux-2.6/arch/moxie/kernel/exception_handler.S&lt;/a&gt;, which you can see
&lt;a href="http://github.com/atgreen/moxiedev/blob/4b1f3184f4a73347008c845d25e3f968f2afc569/linux-2.6/arch/moxie/kernel/exception_handler.S"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Next, I'll get uClibc to make system calls into the kernel so we can try
the same program with libc.a's &lt;code&gt;puts()&lt;/code&gt;.&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Speed bumps on the road to moxie userland</title><link href="http://moxielogic.github.io/blog/speed-bumps-on-the-road-to-moxie-userland.html" rel="alternate"></link><published>2009-07-30T13:46:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-30:blog/speed-bumps-on-the-road-to-moxie-userland.html</id><summary type="html">&lt;p&gt;Sooo..... it turns out there's lots to take care of before userland apps
like BusyBox can run.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The root filesystem&lt;/strong&gt;. This one is easy. I just built a short
    Hello World application in C with moxie-uclinux-gcc. This produces
    an executable in &lt;a href="http://www.beyondlogic.org/uClinux/bflt.htm"&gt;BFLT format&lt;/a&gt; which I call 'init'. The kernel
    build machinery takes this and produces a compressed root filesystem
    image linked to the vmlinux binary. The good news is that the kernel
    is able to boot, detect this &lt;a href="http://www.linuxfordevices.com/c/a/Linux-For-Devices-Articles/Introducing-initramfs-a-new-model-for-initial-RAM-disks/"&gt;initramfs&lt;/a&gt;, decompress it and load
    the init executable (which involves fixing up all of init's
    relocations). My Hello World doesn't actually use the C library or
    any system calls. It just writes Hello through &lt;a href="http://spindazzle.org/greenblog/index.php?/archives/107-ggx-Hello-World!.html"&gt;direct communication
    with the simulator via our software interrupt (swi) instruction&lt;/a&gt;.
    I thought this would let me avoid dealing with system calls for now.
    I was wrong...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System calls&lt;/strong&gt;. This one is harder. Obviously (in retrospect!) the
    kernel creates the init process via the execve system call.
    Implementing system call support involves lots of platform dependent
    stuff. For instance, how do we invoke system calls? How are
    parameters passed? How do we switch back and forth between userland
    and the kernel? The first question is easy: I'll use our trusty
    &lt;a href="http://moxielogic.org/wiki/index.php?title=Instruction_Set#swi"&gt;software interrupt (swi) instruction&lt;/a&gt; to invoke system calls.
    This means creating an exception handler and installing it as
    described &lt;a href="http://moxielogic.org/blog/?p=148"&gt;in this old post&lt;/a&gt;. &lt;br /&gt;
   As an aside, the swi instruction takes a 32-bit immediate operand.
    We currently use this to identify &lt;a href="http://spindazzle.org/greenblog/index.php?/archives/107-ggx-Hello-World!.html"&gt;calls to the simulator via
    libgloss&lt;/a&gt;. This works well for escaping to the
    simulator, but isn't the best way to identify system calls to the
    kernel. The Linux kernel is going to ignore this operand, and we'll
    pass the system call ID in a register instead. This avoids us having
    to do complex instruction decoding in the exception handler
    processing the interrupt (also trashing any future data cache).
    Libgloss and the sim only need a small number of IDs, so I'm going
    to chop the swi instruction down from 48-bits to 16-bits in a future
    build of the tools. &lt;br /&gt;
   Passing arguments to the system calls was also interesting to sort
    out...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System call argument passing&lt;/strong&gt;. The moxie ABI currently only has
    two registers being used to hold function arguments. The remaining
    arguments must live on the stack. This decision goes back to when we
    only had 8 registers to play with. It turns out that Linux kernel
    system calls can have a maximum of 5 arguments. In order to avoid
    tricky argument marshaling, I've decided to try changing the general
    ABI accordingly, so that up to 5 registers may be used to hold
    function arguments. This involves changes to the compiler, debugger
    and a smattering of assembly language in libgloss.&lt;br /&gt;
   The great thing about having integrated benchmarks into the
    &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt; environment is that you can easily compare before and
    after performance for ABI changes like this. Running "ant benchmark"
    runs through the &lt;a href="http://www.eecs.umich.edu/mibench/"&gt;MiBench benchmark suite&lt;/a&gt; and saves a nice report
    for easy comparison. It turns out that switching from 2 to 5
    register arguments is almost universally a win in terms of both code
    size and instruction trace length (an approximation of run time).
    The consumer jpeg benchmarks were slightly larger and slower, but
    only by less than 1%. Every other benchmark result was slightly
    better. The one outlier was the "network_dijkstra" benchmark which
    ended up 44% "faster" (44% fewer instructions being executed).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The first real moxie compiler bug&lt;/strong&gt;. Sometimes things just don't
    work! This is especially true when you're tracking the bleeding edge
    from upstream. I won't go into the details, but I discovered a rare
    bug in the compiler where it would assume that compare results could
    live across function calls. Fortunately I was able to track down the
    guilty compilation pass and disable it with
    &lt;code&gt;-fno-rerun-cse-after-loop&lt;/code&gt;. I know that some people have brought up
    kernels without the benefit of a nice debugger, but I just don't see
    how that is possible. The simulator, and a solid gdb port with
    reverse debugging capabilities have proven to be invaluable!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There's still lots to figure out and implement in the system call space,
but it's clear that we're getting very close to running our first Linux
program!&lt;/p&gt;</summary><category term="architecture"></category><category term="gcc"></category><category term="linux"></category></entry><entry><title>The start of a uClinux userland</title><link href="http://moxielogic.github.io/blog/the-start-of-a-uclinux-userland.html" rel="alternate"></link><published>2009-07-28T15:24:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-28:blog/the-start-of-a-uclinux-userland.html</id><summary type="html">&lt;p&gt;Before we can start building &lt;a href="http://www.busybox.net"&gt;BusyBox&lt;/a&gt;, we need a few more bits of
technology...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.uclibc.org"&gt;uClibc&lt;/a&gt;: this is a popular embedded C library, like newlib, but
    used more often in Linux environments. I ported uClibc to the moxie
    core just like every other bit of software in this project: quickly!
    My strategy has always been to make things link as quickly as
    possible, and then sort out the details later. This seems to be a
    workable strategy in the presence of good testsuites and the like.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cvs.uclinux.org/cgi-bin/cvsweb.cgi/elf2flt/"&gt;elf2flt&lt;/a&gt;: this utility turns moxie ELF binaries into the ["Binary
    Flat" (BFLT) format][] currently required by my Linux port. The BFLT
    format is required because: (a) we don't have an MMU yet, so there's
    a single address space for the kernel and all applications, and (b)
    my moxie tools port doesn't yet support something like the [FR-V's
    FDPIC ABI][] that would allow for proper shared library support in
    the absence of an MMU. elf2flt ends up wrapping the installed
    linker, so builds actually produce BFLT binaries without any extra
    step.&lt;/li&gt;
&lt;li&gt;a moxie-uclinux toolchain: I build this from the same sources as the
    moxie-elf toolchain, but with a sysroot containing the kernel and
    uClibc header files.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is all built and committed to &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt;, which means that you
can check it out and build it yourself with a single "ant build". I
haven't tried using it yet, and I know it will fail in its current
state. The next step is to build BusyBox with the moxie-uclinux
toolchain and create an &lt;a href="http://www.linuxfordevices.com/c/a/Linux-For-Devices-Articles/Introducing-initramfs-a-new-model-for-initial-RAM-disks/"&gt;initramfs&lt;/a&gt; that we can link directly to the
kernel binary. That's when the debugging fun begins...&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>The first moxie linux boot output...</title><link href="http://moxielogic.github.io/blog/the-first-moxie-linux-boot-output.html" rel="alternate"></link><published>2009-07-26T12:43:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-26:blog/the-first-moxie-linux-boot-output.html</id><summary type="html">&lt;p&gt;Userland, here I come! Check out &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt;, run "ant build", then do
the following...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;./root/usr/bin/moxie-elf-run linux-2.6/vmlinux
Linux version 2.6.31-rc3-gb006656-dirty &lt;span class="o"&gt;(&lt;/span&gt;green@dev.moxielogic.com&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;gcc version 4.5.0 &lt;span class="m"&gt;20090715&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;experimental&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;trunk revision 149693&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;GCC&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#6 Sun Jul 26 12:03:14 EDT 2009&lt;/span&gt;
console &lt;span class="o"&gt;[&lt;/span&gt;earlyser0&lt;span class="o"&gt;]&lt;/span&gt; enabled
setup_cpuinfo: initialising
setup_memory: Main mem: 0x0-0x1000000, size 0x01000000
setup_memory: kernel &lt;span class="nv"&gt;addr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00001000-0x002cc000 &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x002cb000
setup_memory: max_mapnr: 0x1000
setup_memory: min_low_pfn: 0x0
setup_memory: max_low_pfn: 0x1000
On node &lt;span class="m"&gt;0&lt;/span&gt; totalpages: 4096
free_area_init_node: node 0, pgdat 002621b0, node_mem_map 002cd000
  Normal zone: &lt;span class="m"&gt;32&lt;/span&gt; pages used &lt;span class="k"&gt;for&lt;/span&gt; memmap
  Normal zone: &lt;span class="m"&gt;0&lt;/span&gt; pages reserved
  Normal zone: &lt;span class="m"&gt;4064&lt;/span&gt; pages, LIFO batch:0
Built &lt;span class="m"&gt;1&lt;/span&gt; zonelists in Zone order, mobility grouping off.  Total pages: 4064
Kernel &lt;span class="nb"&gt;command &lt;/span&gt;line: &lt;span class="nv"&gt;lpj&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1000
PID &lt;span class="nb"&gt;hash &lt;/span&gt;table entries: &lt;span class="m"&gt;64&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;order: 6, &lt;span class="m"&gt;256&lt;/span&gt; bytes&lt;span class="o"&gt;)&lt;/span&gt;
Dentry cache &lt;span class="nb"&gt;hash &lt;/span&gt;table entries: &lt;span class="m"&gt;2048&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;order: 1, &lt;span class="m"&gt;8192&lt;/span&gt; bytes&lt;span class="o"&gt;)&lt;/span&gt;
Inode-cache &lt;span class="nb"&gt;hash &lt;/span&gt;table entries: &lt;span class="m"&gt;1024&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;order: 0, &lt;span class="m"&gt;4096&lt;/span&gt; bytes&lt;span class="o"&gt;)&lt;/span&gt;
Memory: 13376k/16384k available
start_kernel&lt;span class="o"&gt;()&lt;/span&gt;: bug: interrupts were enabled *very* early, fixing it
NR_IRQS:32
 &lt;span class="c"&gt;#0 at 0x00000000, num_irq=0, edge=0x0&lt;/span&gt;
 &lt;span class="c"&gt;#0 at 0x00000000, irq=0&lt;/span&gt;
start_kernel&lt;span class="o"&gt;()&lt;/span&gt;: bug: interrupts were enabled early
ODEBUG: &lt;span class="m"&gt;3&lt;/span&gt; of &lt;span class="m"&gt;3&lt;/span&gt; active objects replaced
ODEBUG: selftest passed
Calibrating delay loop &lt;span class="o"&gt;(&lt;/span&gt;skipped&lt;span class="o"&gt;)&lt;/span&gt; preset value.. 0.20 BogoMIPS &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lpj&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1000&lt;span class="o"&gt;)&lt;/span&gt;
Mount-cache &lt;span class="nb"&gt;hash &lt;/span&gt;table entries: 512
NET: Registered protocol family 16
bio: create slab  at 0
NET: Registered protocol family 2
IP route cache &lt;span class="nb"&gt;hash &lt;/span&gt;table entries: &lt;span class="m"&gt;1024&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;order: 0, &lt;span class="m"&gt;4096&lt;/span&gt; bytes&lt;span class="o"&gt;)&lt;/span&gt;
TCP established &lt;span class="nb"&gt;hash &lt;/span&gt;table entries: &lt;span class="m"&gt;512&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;order: 0, &lt;span class="m"&gt;4096&lt;/span&gt; bytes&lt;span class="o"&gt;)&lt;/span&gt;
TCP &lt;span class="nb"&gt;bind hash &lt;/span&gt;table entries: &lt;span class="m"&gt;512&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;order: -1, &lt;span class="m"&gt;2048&lt;/span&gt; bytes&lt;span class="o"&gt;)&lt;/span&gt;
TCP: Hash tables configured &lt;span class="o"&gt;(&lt;/span&gt;established &lt;span class="m"&gt;512&lt;/span&gt; &lt;span class="nb"&gt;bind &lt;/span&gt;512&lt;span class="o"&gt;)&lt;/span&gt;
TCP reno registered
NET: Registered protocol family 1
ROMFS MTD &lt;span class="o"&gt;(&lt;/span&gt;C&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="m"&gt;2007&lt;/span&gt; Red Hat, Inc.
msgmni has been &lt;span class="nb"&gt;set &lt;/span&gt;to 26
io scheduler noop registered
io scheduler anticipatory registered
io scheduler deadline registered
io scheduler cfq registered &lt;span class="o"&gt;(&lt;/span&gt;default&lt;span class="o"&gt;)&lt;/span&gt;
brd: module loaded
nbd: registered device at major 43
uclinux&lt;span class="o"&gt;[&lt;/span&gt;mtd&lt;span class="o"&gt;]&lt;/span&gt;: RAM probe &lt;span class="nv"&gt;address&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x2cba18 &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x0
Creating &lt;span class="m"&gt;1&lt;/span&gt; MTD partitions on &lt;span class="s2"&gt;&amp;quot;RAM&amp;quot;&lt;/span&gt;:
0x000000000000-0x000000000000 : &lt;span class="s2"&gt;&amp;quot;ROMfs&amp;quot;&lt;/span&gt;
mtd: partition &lt;span class="s2"&gt;&amp;quot;ROMfs&amp;quot;&lt;/span&gt; is out of reach -- disabled
TCP cubic registered
NET: Registered protocol family 17
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
VFS: Cannot open root device &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt; or unknown-block&lt;span class="o"&gt;(&lt;/span&gt;0,0&lt;span class="o"&gt;)&lt;/span&gt;
Please append a correct &lt;span class="s2"&gt;&amp;quot;root=&amp;quot;&lt;/span&gt; boot option&lt;span class="p"&gt;;&lt;/span&gt; here are the available partitions:
Rebooting in &lt;span class="m"&gt;120&lt;/span&gt; seconds..
Machine restart...

Stack:
  00823e50 00823e68 000044e6 fffffff3 002288e0 fa3c0600 00823e7c 0001e196 
  19981fc0 &lt;span class="m"&gt;00000000&lt;/span&gt; 0001d4bf 00823ec0 0003ef30 &lt;span class="m"&gt;00000000&lt;/span&gt; 00229ba8 &lt;span class="m"&gt;00000078&lt;/span&gt; 
  &lt;span class="m"&gt;00000000&lt;/span&gt; 19981fc0 &lt;span class="m"&gt;00000000&lt;/span&gt; 0003ef84 000fe422 0007091a &lt;span class="m"&gt;00008001&lt;/span&gt; &lt;span class="m"&gt;00000018&lt;/span&gt; 
Call Trace:

&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;000044e6&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; machine_restart+0x14/0x1a
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;0001e196&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; emergency_restart+0xe/0x10
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;0001d4bf&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; sys_rt_sigtimedwait+0x15/0x1de
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;0003ef30&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; panic+0x11e/0x172
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;0003ef84&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; printk+0x0/0x1a
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;000fe422&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; strchr+0x0/0x4a
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;0007091a&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; sys_mount+0x0/0xf4
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;00008001&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; update_curr.clone.4+0x115/0x178
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;0003ef84&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; printk+0x0/0x1a
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;00266bca&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; mount_block_root+0x2d0/0x2f4
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;00008001&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; update_curr.clone.4+0x115/0x178
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;00266d94&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; mount_root+0x7c/0x86
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;00266f38&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; prepare_namespace+0x19a/0x1e6
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;00001314&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; do_one_initcall+0x0/0x280
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;00001314&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; do_one_initcall+0x0/0x280
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;002667ba&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; kernel_init+0xea/0x104
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;000025c8&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; kernel_thread_helper+0x8/0x14
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;002666d0&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; kernel_init+0x0/0x104
&lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;000025c0&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; kernel_thread_helper+0x0/0x14

program stopped with signal 2.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There are lots of short cuts that need to be cleaned up, but it seems
that I'm basically at the point where I need to worry about userland.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://www.busybox.net"&gt;Busybox&lt;/a&gt;, I'm looking at you!&lt;/strong&gt;&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Kernel update: device trees and kernel threads</title><link href="http://moxielogic.github.io/blog/kernel-update-device-trees-and-kernel-threads.html" rel="alternate"></link><published>2009-07-25T04:50:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-25:blog/kernel-update-device-trees-and-kernel-threads.html</id><summary type="html">&lt;p&gt;I've spent a lot of time in airports/planes/hotels recently, which is
good news for the moxie linux port. It runs about 6.5M instructions,
booting up to the point where a couple of kernel threads are created.
However, a few context switches later it all comes tumbling down. I
didn't have any of my kernel books with me, so I stopped hacking at that
point rather than try to guess/decode how some of the internals are
supposed to work.&lt;/p&gt;
&lt;p&gt;My port is using a device tree to describe the system architecture. This
makes it easier to build a single kernel image that can boot on multiple
moxie implementations. There's a good paper on this relatively new
infrastructure here:
&lt;a href="http://ols.fedoraproject.org/OLS/Reprints-2008/likely2-reprint.pdf"&gt;http://ols.fedoraproject.org/OLS/Reprints-2008/likely2-reprint.pdf&lt;/a&gt;. If
you've been following this project, you may recall that console I/O is
implemented differently on the gdb and qemu simulators. For the gdb
simulator we use a software interrupt instruction (swi) to &lt;a href="http://spindazzle.org/greenblog/index.php?/archives/107-ggx-Hello-World!.html"&gt;escape to
the simulator&lt;/a&gt;, but the qemu port uses a real &lt;a href="http://moxielogic.org/blog/?p=23"&gt;simulated serial
device&lt;/a&gt;. This means they need different console devices in the kernel
to print boot messages. The device tree is a nice way to describe
differences like this and have a single kernel image to boot in both
environments.&lt;/p&gt;
&lt;p&gt;Also, as predicted, I actually used moxie gdb's &lt;a href="http://moxielogic.org/blog/?p=290"&gt;reverse debugging&lt;/a&gt;
feature to help debug my kernel bring-up. It was &lt;em&gt;really&lt;/em&gt; useful a
couple of times and has probably saved me the amount of effort required
to implement it in the first place already!&lt;/p&gt;
&lt;p&gt;The next week is going to be very busy for me, so I don't expect to get
much done. We'll see...&lt;/p&gt;</summary><category term="gdb"></category><category term="linux"></category><category term="qemu"></category></entry><entry><title>The Moxie Linux port</title><link href="http://moxielogic.github.io/blog/the-moxie-linux-port.html" rel="alternate"></link><published>2009-07-23T03:50:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-23:blog/the-moxie-linux-port.html</id><summary type="html">&lt;p&gt;I've just checked the start of the kernel port into &lt;a href="http://www.moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt;.
Running "ant build" will produce tools, simulators, u-boot and now a
vmlinux you can run with moxie-elf-run or in gdb. It crashes on startup
right now, but that's to be expected. I just got it to the point where
it links. More to come...&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Reverse debugging!</title><link href="http://moxielogic.github.io/blog/reverse-debugging.html" rel="alternate"></link><published>2009-07-12T21:55:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-07-12:blog/reverse-debugging.html</id><summary type="html">&lt;p&gt;A few weeks ago I happened to be in Palo Alto and met up with my friend
and long-time GDB hacker Michael Snyder. He told me about a new feature
in GDB called "process recording". The basic idea is that when you tell
GDB to enter into "record mode", it records undo information for every
instruction executed during the debug process. This lets you switch
direction and start stepping through your code backwards in time! It's a
pretty amazing feature.&lt;/p&gt;
&lt;p&gt;I was anxious to implement it for moxie, but only got around to it this
weekend. The &lt;a href="http://www.moxielogic.org/wiki/index.php?title=Instruction_Set"&gt;moxie ISA&lt;/a&gt; is relatively small, so it wasn't much work.
The patch looks something like &lt;a href="http://github.com/atgreen/moxiedev/commit/e8940639760db3ae05f01ef205d93d85fb3f4ab1"&gt;this&lt;/a&gt;. And, as promised, you can now
step forwards and backwards through moxie code. Reverse "continue" and
"finish" also work. It's going to be really handy when I get back to
working the Linux kernel port.&lt;/p&gt;
&lt;p&gt;Some GDB front-ends already have the controls in place for reverse
debugging. Here's a webinar &lt;a href="http://live.eclipse.org/node/723"&gt;showing reverse debugging on Eclipse&lt;/a&gt;. I
mostly use Emacs as my moxie-elf-gdb frontend, but I'm not sure if it
supports the reverse instructions nicely yet (of course you can "set
exec-direction reverse" and use the normal step/next/continue commands).&lt;/p&gt;
&lt;p&gt;Thanks to Micheal for pointing me at this new feature, and to Tea Water
for implementing process recording in the first place.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt;Emacs support for reverse debugging &lt;a href="http://sourceware.org/ml/gdb/2009-07/msg00094.html"&gt;should be arriving in
23.2&lt;/a&gt;. I'm not sure what the schedule for that is, but 23.1 is
supposed to come out next week (July 22).&lt;/p&gt;</summary><category term="gdb"></category></entry><entry><title>A Disassembler in Verilog</title><link href="http://moxielogic.github.io/blog/a-disassembler-in-verilog.html" rel="alternate"></link><published>2009-06-22T18:55:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-06-22:blog/a-disassembler-in-verilog.html</id><summary type="html">&lt;p&gt;I've been playing around a little more with verilog. Here's a mostly
complete moxie &lt;a href="http://github.com/atgreen/moxiedev/blob/fb57efc73e47e451f18951d274c41ccda337c112/moxie/rtl/verilog/iprinter.v"&gt;disassembler module&lt;/a&gt; written in verilog.&lt;/p&gt;
&lt;p&gt;And here's a little &lt;a href="http://github.com/atgreen/moxiedev/blob/fb57efc73e47e451f18951d274c41ccda337c112/moxie/rtl/verilog/testsuite/moxie.modules/test-iprinter.v"&gt;driver&lt;/a&gt; for it. The driver reads a hex dump file
into an array representing memory. On every clock cycle it updates the
instruction and data output registers and increments the program
counter. The disassembler samples those values on every cycle, and tells
the driver how far to increment the PC. Pretty basic stuff!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;moxie-elf-gcc -o hello.x hello.c -Tsim.ld
&lt;span class="nv"&gt;$ &lt;/span&gt;moxie-elf-objdump hello.x -O verilog hello.vh
&lt;span class="nv"&gt;$ &lt;/span&gt;iverilog &lt;span class="nb"&gt;test&lt;/span&gt;-iprinter.v ../../iprinter.v
&lt;span class="nv"&gt;$ &lt;/span&gt;./a.out
        ldi.l   &lt;span class="nv"&gt;$sp&lt;/span&gt; ,   0x00400000
        ldi.l   &lt;span class="nv"&gt;$fp&lt;/span&gt; ,    0x00000000
        dec     &lt;span class="nv"&gt;$sp&lt;/span&gt; ,     12
        ldi.l   &lt;span class="nv"&gt;$r0&lt;/span&gt; ,    0x000128b4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;etc etc etc&lt;/p&gt;
&lt;p&gt;Nothing too impressive really. I've stuck this test code in a directory
hierarchy that would be useful for dejagnu, as I plan on using dejagnu
for regression testing the various HDL modules.&lt;/p&gt;</summary></entry><entry><title>ISA improvements</title><link href="http://moxielogic.github.io/blog/isa-improvements.html" rel="alternate"></link><published>2009-06-11T05:19:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-06-11:blog/isa-improvements.html</id><summary type="html">&lt;p&gt;I've committed the PC-relative branch instruction changes upstream. But
this is just one of many ISA improvements that need to happen. Here are
a handful of other ideas off the top of my head. None of these projects
should be particularly difficult.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shorten load/store offsets to 16-bits. They are currently 32-bits,
    but for all of the benchmarks I've looked at the upper 16-bits are
    always 0x0000 or 0xffff. If the compiler ever really wants to use an
    offset &amp;gt; 16-bits, it should revert to computing the target address
    in registers. I don't expect that much code would require this.&lt;/li&gt;
&lt;li&gt;Introduce shift instructions with immediate operands. There's plenty
    of opcode space for us to add 16-bit shift instructions that include
    a 5-bit immediate shift value (so we can shift up to 32-bits in
    either direction). Right now we load a 32-bit immediate shift value
    into a register which burns that register as well as wastes 32-bits
    of code space per shift.&lt;/li&gt;
&lt;li&gt;Get the compiler to generate 16-bit immediate loads. All immediates
    are 32-bits right now, but the vast majority of these constants are
    &amp;lt; 16 bits long.&lt;/li&gt;
&lt;li&gt;Push/pop multiple registers to the stack with one instruction.
    Although we have 16-registers, the ABI doesn't have us pushing all
    16 to the stack on function entry. We should be able to have a
    single 16-bit instruction that pushes/pops all of the relevant
    registers in one go. The instruction would include a bitmap
    identifying the registers we need to push/pop. ARM has something
    like this. The only drawback I can think of is that it could
    increase interrupt latencies as we'd probably have to retire the
    entire instruction (~10 memory writes/reads) before servicing an
    interrupt.&lt;/li&gt;
&lt;li&gt;Many register rich ISAs include one register that is hardwired to
    zero. We could try this to see if it makes a difference, but I doubt
    it would be a win. Another idea would be to create a &lt;code&gt;cmpz&lt;/code&gt;
    instruction to compare a register to zero so we don't have to burn a
    register for this common operation. Maybe cmp1 might even make
    sense. This is easy to measure.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those are some of the obvious ones, and all I have time to write about
now.&lt;/p&gt;</summary><category term="architecture"></category></entry><entry><title>Moxie GCC port is upstream!</title><link href="http://moxielogic.github.io/blog/moxie-gcc-port-is-upstream.html" rel="alternate"></link><published>2009-06-09T21:41:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-06-09:blog/moxie-gcc-port-is-upstream.html</id><summary type="html">&lt;p&gt;The moxie port has been &lt;a href="http://gcc.gnu.org/ml/gcc/2009-06/msg00194.html"&gt;accepted by the GCC steering committee&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;I just &lt;a href="http://gcc.gnu.org/viewcvs?view=rev&amp;amp;revision=148339"&gt;checked it in&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That is all.&lt;/p&gt;</summary><category term="gcc"></category></entry><entry><title>Everything is relative (finally!)</title><link href="http://moxielogic.github.io/blog/everything-is-relative-finally.html" rel="alternate"></link><published>2009-06-07T17:57:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-06-07:blog/everything-is-relative-finally.html</id><summary type="html">&lt;p&gt;The Moxie ISA still needs quite a bit of tuning. Take branches, for
instance. A &lt;code&gt;beq&lt;/code&gt; instruction currently encoded &lt;a href="http://www.moxielogic.org/wiki/index.php?title=Instruction_Set#beq"&gt;like so&lt;/a&gt;...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;`00001111xxxxxxxx iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii`
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...where the "&lt;code&gt;x&lt;/code&gt;"s represent "don't care" bits, and "&lt;code&gt;i&lt;/code&gt;"s are a
32-bit absolute branch target. That's right -- branch targets are not PC
relative! This is hugely wasteful.&lt;/p&gt;
&lt;p&gt;I've finally got around to fixing this. Here's how I did it...&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;I recoded all branch instructions as "Form 3" instructions, and
    tweaked the as-of-yet unused Form 3 encodings so they look like
    this:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  FORM 3 instructions start with a bits &amp;quot;11&amp;quot;...

    11oooovvvvvvvvvv                                                            
    0              F

   oooo         - form 3 opcode number                                          
   vvvvvvvvvv   - 10-bit immediate value.
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;This gives us 16 opcodes with a 10-bit immediate value. There are
only 9 branch instructions, so we have a bit of room left in the
Form 3 opcode space.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I introduced a new 10-bit PC-relative Moxie relocation in BFD. This
    tells the linker and friends how to process PC-relative relocations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;I hacked the assembler to generate these new relocations instead of
    simply emitting a 32-bit absolute address.&lt;/li&gt;
&lt;li&gt;I hacked the disassembler to print the new Form 3 instructions out
    nicely.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finally, I taught the compiler how to emit valid branch
    instructions. It's not that they look any different now; it's just
    that you need to worry about branch targets that exceed our 10-bit
    range. Actually, we have an 11-bit range because we know that all
    instructions are 16-bit aligned. This lets us drop the bottom bit
    from the encoding since we know it will always be &lt;code&gt;0&lt;/code&gt;.&lt;br /&gt;
    An 11-bit range lets us branch about 1k backwards to 1k forwards.
    If the compiler detects that a branch target is out of range, we
    want it to do something like the following transformation...&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    beq    .FAR_TARGET
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;...becomes...&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    bne    . + 8
    jmpa   .FAR_TARGET
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;The "&lt;code&gt;bne .+8&lt;/code&gt;" line means branch forward 8 bytes from the current
PC. This would skip the unconditional jump to &lt;code&gt;.FAR_TARGET&lt;/code&gt; (a
6-byte instruction + 2-bytes for the branch = 8). Note that we have
to reverse the logic from "&lt;code&gt;beq&lt;/code&gt;" to "&lt;code&gt;bne&lt;/code&gt;" for this to make sense.&lt;/p&gt;
&lt;p&gt;This is only possible if GCC can tell how far away the branch
targets are. Fortunately, we're able to annotate instructions in the
machine description file (&lt;code&gt;moxie.md&lt;/code&gt;) with their length; currently
either 2 or 6 bytes long. GCC then processes these annotations to
determine branch distances.&lt;/p&gt;
&lt;p&gt;Now that we know branch distances at compile time, the compiler can
do smart instruction selection to deal with out-of-range branches.
The changes were quite simple and limited to the .md file in the
backend.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The savings after this ISA change are substantial. For instance, the
consumer_jpeg_c benchmark in &lt;a href="http://www.moxielogic.org/wiki/index.php?title=MoxieDev"&gt;MoxieDev&lt;/a&gt; is more than 15% smaller
when we use PC-relative branches! The &lt;a href="http://www.denx.de/wiki/U-Boot"&gt;u-boot&lt;/a&gt; binary, on the other
hand, is "only" 7% smaller.&lt;/p&gt;
&lt;p&gt;I hope to commit these changes to SRC and GCC once the GCC port is
merged upstream. Fingers crossed...&lt;/p&gt;</summary><category term="architecture"></category><category term="binutils"></category><category term="gcc"></category><category term="u-boot"></category></entry><entry><title>An even newer git repo</title><link href="http://moxielogic.github.io/blog/an-even-newer-git-repo.html" rel="alternate"></link><published>2009-05-29T20:05:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-05-29:blog/an-even-newer-git-repo.html</id><summary type="html">&lt;p&gt;So it turns out that hosting a git repo that is only accessible via slow
http is no fun.&lt;/p&gt;
&lt;p&gt;Fortunately, the great team at &lt;a href="http://www.github.com"&gt;github.com&lt;/a&gt; were willing to take this
on, so now the real repository is accessible via this command:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git clone git://github.com/atgreen/moxiedev.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I'm retiring all other repos.&lt;/p&gt;
&lt;p&gt;Also, check out the project page here:
&lt;a href="http://bit.ly/1aeGAj"&gt;http://github.com/atgreen/moxiedev/tree/master&lt;/a&gt;. Note the early-90s
era ASCII graphics in the new &lt;a href="http://bit.ly/waG8H"&gt;README&lt;/a&gt; file. Sweet.&lt;/p&gt;</summary><category term="releng"></category></entry><entry><title>New git repo</title><link href="http://moxielogic.github.io/blog/new-git-repo.html" rel="alternate"></link><published>2009-05-26T20:05:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-05-26:blog/new-git-repo.html</id><summary type="html">&lt;p&gt;I'll bottom line this one quickly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;moxiedev&lt;/a&gt; is now maintained with git. Check it out like so..&lt;br /&gt;
&lt;code&gt;$ git clone http://moxielogic.org/moxiedev.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;moxiedev now contains a partial &lt;a href="http://moxielogic.org/blog/?p=154"&gt;u-boot port&lt;/a&gt;. It's "partial"
    because I fat fingered some commands and blew away four or five
    important files. They will have to be recreated before this thing
    builds.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lessons learned:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hg is much more intuitive than git. Unfortunately hg and/or my hg
    hoster was having problems with the size of moxiedev, necessitating
    a change. Hosting a public git repo on my own system seemed like the
    easiest thing.&lt;/li&gt;
&lt;li&gt;Make sure you backup &lt;strong&gt;&lt;em&gt;everything&lt;/em&gt;&lt;/strong&gt;. I am cursing myself for not
    having pushed out the u-boot port much sooner (but I had to move off
    of the hg system first).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BTW - still waiting on GCC steering committee decision on inclusion of
moxie port.&lt;/p&gt;</summary><category term="releng"></category><category term="u-boot"></category></entry><entry><title>RPMs</title><link href="http://moxielogic.github.io/blog/rpms.html" rel="alternate"></link><published>2009-05-07T17:37:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-05-07:blog/rpms.html</id><summary type="html">&lt;p&gt;There's a little more detail on the &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;wiki&lt;/a&gt;, but basically...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;rpm -ivh http://moxielogic.org/download/moxielogic-repo-1-1.noarch.rpm
&lt;span class="nv"&gt;$ &lt;/span&gt;yum groupinstall moxiedev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Your welcome.&lt;/p&gt;
&lt;p&gt;Seriously though... release engineering is at times both tedious and
fascinating. But mostly tedious. Still, I was interested in tackling a
little releng work this week before responding to Ian's first &lt;a href="http://gcc.gnu.org/ml/gcc-patches/2009-05/msg00059.html"&gt;compiler
review comments&lt;/a&gt; or continuing the verilog hacking. Now, to move on to
more interesting things...&lt;/p&gt;</summary><category term="releng"></category></entry><entry><title>Quick update...</title><link href="http://moxielogic.github.io/blog/quick-update.html" rel="alternate"></link><published>2009-04-29T22:38:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-29:blog/quick-update.html</id><summary type="html">&lt;p&gt;A few quick &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;MoxieDev&lt;/a&gt; updates...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The verilog output patch is in binutils&lt;/li&gt;
&lt;li&gt;The moxie ports for binutils, newlib, libgloss and gdb are all
    upstream. Waiting on sim and gcc reviews.&lt;/li&gt;
&lt;li&gt;The upstream qemu team have switched to git, so I've rebased
    MoxieDev's qemu against this new repository.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, I've been reading the new &lt;a href="http://www.opensparc.net/publications/books/opensparc-internals.html"&gt;OpenSPARC Internals&lt;/a&gt; book. It's not
quite what I was hoping it would be, but Chapter 7, OpenSPARC Design
Verification Methodology, is fantastic. You can download it for free
from &lt;a href="http://www.sun.com/offers/details/OpenSPARC_Internals_Book.html"&gt;this page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I, however, bought this book from Amazon. And what's interesting here is
that it was printed by &lt;a href="http://en.wikipedia.org/wiki/Bob_Young_(businessman)"&gt;Bob Young&lt;/a&gt;'s self-publishing startup,
&lt;a href="http://www.lulu.com"&gt;Lulu&lt;/a&gt;. It looks/smells/feels like a real book. I don't know why I
find this amazing, but I do. Bravo Bob!&lt;/p&gt;</summary><category term="binutils"></category><category term="gdb"></category><category term="newlib"></category><category term="qemu"></category></entry><entry><title>Loading programs into the verilog simulation</title><link href="http://moxielogic.github.io/blog/loading-programs-into-the-verilog-simulation.html" rel="alternate"></link><published>2009-04-22T13:38:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-22:blog/loading-programs-into-the-verilog-simulation.html</id><summary type="html">&lt;p&gt;The moxie newlib port was &lt;a href="http://sourceware.org/ml/newlib/2009/msg00520.html"&gt;just accepted&lt;/a&gt;. The GCC port will take a
little longer to review, but I hope that it will get accepted early next
week. Already there has been some useful feedback resulting in a few
improvements. For instance, the moxie libgcc.a now provides the soft-fp
floating point emulation library instead of the fpbit one. Apparently
it's harder/better/faster/stronger, and other ports are starting to
adopt it. See the &lt;a href="http://ols.fedoraproject.org/GCC/Reprints-2006/sidwell-reprint.pdf"&gt;"Improving Software Floating Point Support" paper&lt;/a&gt;
from the 2006 GCC Summit Proceedings&lt;/a&gt; for details.&lt;/p&gt;
&lt;p&gt;&lt;object width="425" height="344"&gt;
&lt;param name="movie" value="http://www.youtube.com/v/K2cYWfq--Nw&amp;amp;hl=en&amp;amp;fs=1"&gt;&lt;/param&gt;&lt;param name="allowFullScreen" value="true"&gt;&lt;/param&gt;&lt;param name="allowscriptaccess" value="always"&gt;&lt;/param&gt;&lt;/p&gt;
&lt;p&gt;&lt;embed src="http://www.youtube.com/v/K2cYWfq--Nw&amp;amp;hl=en&amp;amp;fs=1" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="425" height="344"&gt;
&lt;/embed&gt;
&lt;/object&gt;&lt;/p&gt;
&lt;p&gt;On the verilog front, I have what I believe is a first pass at the
Instruction Fetch and Decode (IF/ID) units. In order to test these, you
actually need real code loaded into the simulated memory. Verilog
provides a handy function, $readmemh(), that sucks ASCII hex codes from
a text file into a register array (fake memory). The trick is that the
input file has to be in a very special format. To that end, I've written
a new BFD write-only backend called 'verilog' that generates this hex
dump output. So now...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  $ moxie-elf-gcc -o hello.x hello.c
  $ moxie-elf-objcopy -O verilog hello.x hello.vh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...produces a useful hello.vh, which verilog can load directly
into memory like so...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;module&lt;/span&gt; &lt;span class="nt"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="nt"&gt;reg&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;my_memory&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;64000&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="nt"&gt;initial&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nt"&gt;readmemh&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello.vh&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;my_memory&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="nt"&gt;end&lt;/span&gt;
&lt;span class="nt"&gt;endmodule&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I just &lt;a href="http://sourceware.org/ml/binutils/2009-04/msg00321.html"&gt;submitted this to the binutils list for review&lt;/a&gt;. Keep your
daft fingers crossed!&lt;/p&gt;
&lt;p&gt;And this means I'm just about to start testing my IF/ID units on real
code.&lt;/p&gt;</summary><category term="binutils"></category><category term="gcc"></category><category term="newlib"></category><category term="verilog"></category></entry><entry><title>Pushing Bits Upstream</title><link href="http://moxielogic.github.io/blog/pushing-bits-upstream.html" rel="alternate"></link><published>2009-04-16T17:55:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-16:blog/pushing-bits-upstream.html</id><summary type="html">&lt;p&gt;If there's one thing I've learned about GNU tools development over the
years, it's that attempting to maintain a tools port outside of the
upstream tree is A Very Bad Idea! It's easy to let your private tree
fall out of sync from upstream. And the longer you wait to fix things,
the more expensive it becomes.&lt;/p&gt;
&lt;p&gt;&lt;img alt="img00017-20090402-12411" src="http://moxielogic.org/blog/wp-content/uploads/2009/04/img00017-20090402-12411-300x225.jpg" title="img00017-20090402-12411" /&gt;&lt;/p&gt;
&lt;p&gt;So a few weeks ago I submitted my copyright assignment forms to the
&lt;a href="http://www.fsf.org"&gt;FSF&lt;/a&gt; -- an important precondition to getting any port accepted
upstream. Although there's some debate over the value of a having a
single copyright holder for Free Software projects, I trust that the
Free Software Foundation will continue to be an excellent steward of the
GNU toolchain. And, when it comes down to it, there's little choice if
you are interested in participating in GNU tools development.&lt;/p&gt;
&lt;p&gt;Last night I &lt;a href="http://sourceware.org/ml/binutils/2009-04/msg00211.html"&gt;submitted the moxie binutils port&lt;/a&gt; to the binutils
mailing list, and earlier today Nick Clifton &lt;a href="http://sourceware.org/ml/binutils/2009-04/msg00229.html"&gt;accepted them&lt;/a&gt; and
merged them into the upstream src tree! GCC and newlib are next.&lt;/p&gt;</summary><category term="binutils"></category></entry><entry><title>A Verilogical Place To Start *</title><link href="http://moxielogic.github.io/blog/a-verilogical-place-to-start.html" rel="alternate"></link><published>2009-04-07T20:31:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-07:blog/a-verilogical-place-to-start.html</id><summary type="html">&lt;p&gt;I've written my first bit of &lt;a href="http://en.wikipedia.org/wiki/Verilog"&gt;verilog&lt;/a&gt; tonight. It's not much, really,
but it's a start. I'm using &lt;a href="http://www.icarus.com/eda/verilog/"&gt;Icarus Verilog&lt;/a&gt; (iverlog) to compile and
simulate the code. I also plan on using &lt;a href="http://www.gpleda.org/tools/gtkwave/index.html"&gt;GTKWave&lt;/a&gt; to examine timing
dumps from the iverilog simulator. Both of these tools are part of my
development platform, Fedora.&lt;/p&gt;
&lt;p&gt;Rather than plan everything out to the last detail, I'm going to wing it
for a while and explore the language. To start with, I've decided to try
to hack the core together as a simple pipelined processor consisting of
the following four stages: Instruction Fetch, Instruction Decode,
Execute and Write.&lt;/p&gt;
&lt;p&gt;The first complication comes from Moxie's long instructions. Moxie is
not RISC processor, in that it does not have fixed width instructions
that can be fetched in a single go. Most of the instructions are
16-bits, but several of them are 48-bits, the last 32-bits being some
kind of immediate value. We're going to have a 32-bit path to
instruction memory, which means we may have to fetch twice in order to
read a single instruction. This involves state machinery and some tricky
back and forth between the Instruction Fetch and Instruction Decode
pipeline stages. It's taking a while to get straight in my head, so I
don't know when my next update will be.&lt;/p&gt;
&lt;p&gt;* Blog entry title borrowed from &lt;a href="http://assets.cambridge.org/97805218/28666/excerpt/9780521828666_excerpt.pdf"&gt;this great book&lt;/a&gt;&lt;/p&gt;</summary><category term="verilog"></category></entry><entry><title>Das U-Boot on moxie!</title><link href="http://moxielogic.github.io/blog/das-u-boot-on-moxie.html" rel="alternate"></link><published>2009-04-02T16:28:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-02:blog/das-u-boot-on-moxie.html</id><summary type="html">&lt;p&gt;My moxie port of &lt;a href="http://www.denx.de/wiki/U-Boot"&gt;U-Boot&lt;/a&gt;, the Universal Boot Loader, has started
working!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;qemu-system-moxie -nographic -kernel u-boot
SDRAM :
        U-Boot Start:0x00001000
Using default environment

U-BOOT &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;moxiesim&amp;quot;&lt;/span&gt;

&lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; version

U-Boot 2009.03-rc2-00013-gefb4734-dirty &lt;span class="o"&gt;(&lt;/span&gt;Apr &lt;span class="m"&gt;02&lt;/span&gt; &lt;span class="m"&gt;2009&lt;/span&gt; - 20:07:32&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; printenv
&lt;span class="nv"&gt;bootargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;root&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;romfs
&lt;span class="nv"&gt;baudrate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;38400
&lt;span class="nv"&gt;hostname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;moxiesim&amp;quot;&lt;/span&gt;

Environment size: 55/4092 &lt;span class="nv"&gt;bytes&lt;/span&gt;
&lt;span class="o"&gt;=&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It's pretty amazing to have an interactive app running on qemu now.
U-Boot is using the serial port for console communications (we added the
UART to qemu &lt;a href="qemu-says-hello-world.html"&gt;a few blog entries ago&lt;/a&gt;). I haven't added any ethernet
device yet, so all of the networking is configured out for now. There's
not even a timer device, so the sleep command doesn't work. However,
this is still a huge step forward.&lt;/p&gt;
&lt;p&gt;I haven't decided yet if the U-Boot port will live in &lt;a href="http://moxielogic.org/wiki/index.php?title=MoxieDev"&gt;MoxieDev&lt;/a&gt;. It's
already quite huge, and this would add another 130MB or so. I'll sleep
on it.&lt;/p&gt;</summary><category term="u-boot"></category></entry><entry><title>Processor Exceptions</title><link href="http://moxielogic.github.io/blog/processor-exceptions.html" rel="alternate"></link><published>2009-04-02T08:33:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-04-02:blog/processor-exceptions.html</id><summary type="html">&lt;p&gt;My first go at exceptions is working well. The basic idea is that moxie
will have a single exception handling routine whose address lives in
special register 1. You set the exception handler like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;void install_handler(void (*handler)(void))
{
  printf (&amp;quot;Installing handler 0x%x\n&amp;quot;, (unsigned) handler);
  asm(&amp;quot;ssr %0, 1&amp;quot; : : &amp;quot;r&amp;quot; (handler));
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When the processor hits an exception, it performs a standard function
call to the handler. We return from the handler just like it was any old
function, since it currently uses the standard C ABI. The exception type
will be found in special register 2. The current exception types are as
follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;#define MOXIE_EX_DIV0 0 /* Divide by zero */
#define MOXIE_EX_BAD  1 /* Illegal instruction */
#define MOXIE_EX_IRQ  2 /* Interrupt request */
#define MOXIE_EX_SWI  3 /* Software interrupt */
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the case of IRQ and SWI exceptions, the interrupt number will be
found in special register 3. I don't have instructions yet to disable or
enable interrupts, but those are an obvious next step. Here's a sample
exception handler:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;void handler (void)
{
  int et;

  /* Get the exception handler from special register 2.  */
  asm(&amp;quot;gsr %0, 2&amp;quot; : &amp;quot;=r&amp;quot;(et) : &amp;quot;0&amp;quot;(et) );

  switch (et)
    {
    case MOXIE_EX_DIV0:
      printf(&amp;quot;DIVIDE BY ZERO EXCEPTION\n&amp;quot;);
      break;
    case MOXIE_EX_BAD:
      printf(&amp;quot;ILLEGAL INSTRUCTION EXCEPTION\n&amp;quot;);
      break;
    case MOXIE_EX_IRQ:
      {
        int irq;
        asm(&amp;quot;gsr %0, 3&amp;quot; : &amp;quot;=r&amp;quot;(irq) : &amp;quot;0&amp;quot;(irq) );
        printf(&amp;quot;INTERRUPT REQUEST %d\n&amp;quot;, irq);
      }
      break;
    case MOXIE_EX_SWI:
      {
        int swi;
        asm(&amp;quot;gsr %0, 3&amp;quot; : &amp;quot;=r&amp;quot;(swi) : &amp;quot;0&amp;quot;(swi) );
        printf(&amp;quot;SOFTWARE INTERRUPT REQUEST %d\n&amp;quot;, swi);
      }
      break;
    default:
      printf(&amp;quot;UNKNOWN EXCEPTION 0x%x\n&amp;quot;, et);
      break;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The handler for DIV0 and SWI may also want to know where the exception
happened. This can be determined by pulling the return address off of
the stack and subtracting the appropriate instruction length (2 for div
and 6 for swi).&lt;/p&gt;
&lt;p&gt;I've implemented support for this in the qemu port, and the test
directory in moxiedev contains a simple program to exercise this new
functionality. I think we'll want to hook up some peripherals in qemu to
the IRQ system soon.&lt;/p&gt;</summary><category term="architecture"></category></entry><entry><title>Thinking about exceptions....</title><link href="http://moxielogic.github.io/blog/thinking-about-exceptions.html" rel="alternate"></link><published>2009-03-19T14:01:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-19:blog/thinking-about-exceptions.html</id><summary type="html">&lt;p&gt;In reading about how other processors handle exceptions, they seem to be
of two sorts. Some (most?) processors look into a vector of exception
handlers based on the exception type (Divide by Zero, Software
Interrupt, IRQ, etc), and the other sort jumps to a single exception
address and lets the software sort it out. I'm thinking of going this
second route, only because it seems simpler and more flexible. The
address of the handler will live in one of the special registers, and
will need to be initialized with a &lt;a href="http://spindazzle.org/greenblog/index.php?/archives/120-ggx-new-instructions-and-porting-the-Linux-kernel.html"&gt;Set Special Register&lt;/a&gt; (&lt;code&gt;ssr&lt;/code&gt;)
instruction. Next we need to decide on what calling convention to use to
get to the handler. Is there any reason not to use the standard calling
convention? It certainly will make things easier for the debugger and I
maybe I can reuse the stack slot reserved for the static chain pointer
to hold the exception type. Many processors, however, just load the
return address into a reserved register and jump to the handler.
Presumably this is for performance reasons. More thought required... but
feedback welcome!&lt;/p&gt;</summary></entry><entry><title>Adding a Real Time Clock</title><link href="http://moxielogic.github.io/blog/adding-a-real-time-clock.html" rel="alternate"></link><published>2009-03-17T15:38:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-17:blog/adding-a-real-time-clock.html</id><summary type="html">&lt;p&gt;After a UART, one of the most useful and interesting peripherals you can
add to a board is a Real Time Clock (RTC). Qemu comes with a simulation
of Freescale's &lt;a href="http://www.freescale.com/files/microcontrollers/doc/data_sheet/MC146818.pdf"&gt;MC146818&lt;/a&gt; RTC chip. Adding it to our qemu-defined
board was as simple as....&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;   rtc_mm_init(0x400, 0, 0, 0);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This makes the MC146818 available as a memory mapped port at &lt;code&gt;0x400&lt;/code&gt; on
our target board. The simplest way to use this is to implement a qemu
specific &lt;code&gt;time()&lt;/code&gt; function in the qemu BSP that pulls the current time
from the &lt;code&gt;0x400&lt;/code&gt;-mapped port. I won't include the code here, but it's
quite simple, and found in&lt;br /&gt;
&lt;code&gt;moxiedev/src/libgloss/moxie/qemu-time.c&lt;/code&gt;. Now functions like
&lt;code&gt;gettimeofday()&lt;/code&gt; work as expected, making the whole platform a little
more real.&lt;/p&gt;
&lt;p&gt;After an RTC, I think the next most interesting peripheral is an
interrupt controller, but this will require more thought about the
system architecture and how moxie will handle exceptions.&lt;/p&gt;</summary><category term="bsp"></category><category term="qemu"></category></entry><entry><title>Board Support Packages</title><link href="http://moxielogic.github.io/blog/board-support-packages.html" rel="alternate"></link><published>2009-03-17T14:51:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-17:blog/board-support-packages.html</id><summary type="html">&lt;p&gt;Today we're introducing the notion of Board Support Packages (BSPs) to
the &lt;a href="http://moxielogic.org/wiki/index.php?title=Toolchain"&gt;moxie toolchain&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A BSP provides all of the configuration data and code requires to target
a specific hardware platform. This mostly involves linker scripts,
platform initialization code, and hardware abstraction support
libraries.&lt;/p&gt;
&lt;p&gt;Until recently the gdb sim was our only target platform. Now we also
have qemu, which needs to use &lt;a href="http://moxielogic.org/blog/?p=23"&gt;an alternate _write implementation&lt;/a&gt;
in order to send output to a memory mapped UART. What we really need to
do is to define a "qemu" BSP that targets the default "board" defined in
qemu. This BSP will provide a support library with the UART version of
&lt;code&gt;_write&lt;/code&gt;, and the original gdb sim version will live in a "sim" BSP.&lt;/p&gt;
&lt;p&gt;In the world of the GNU toolchain, BSPs live in &lt;a href="http://spindazzle.org/greenblog/index.php?/archives/106-ggx-libgloss,-newlib-and-hello.c.html"&gt;libgloss&lt;/a&gt;. The
libgloss tree now contains BSP specific linker scripts which you must
use in order to pull in either of the BSP support libraries needed by
newlib. So if you want to target qemu, you run...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ moxie-elf-gcc -o hello.x hello.c -Tqemu.ld&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;..and if you want to target the gdb sim, you have to go...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ moxie-elf-gcc -o hello.x hello.c -Tsim.ld&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This will make more sense down the line as we add more target boards
with different memory maps and peripherals.&lt;/p&gt;
&lt;p&gt;Speaking of peripherals.... I've also added a Real Time Clock device to
the qemu board definition which I'll talk about in my next posting.&lt;/p&gt;</summary><category term="bsp"></category><category term="gdb"></category><category term="qemu"></category></entry><entry><title>Debugging with the moxie qemu simulator</title><link href="http://moxielogic.github.io/blog/debugging-with-the-moxie-qemu-simulator.html" rel="alternate"></link><published>2009-03-14T06:58:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-14:blog/debugging-with-the-moxie-qemu-simulator.html</id><summary type="html">&lt;p&gt;I've finally cracked the gdb+qemu puzzle, so now we can debug code
running on the qemu moxie simulator!&lt;/p&gt;
&lt;p&gt;The last little gotcha was that the simulated $pc wasn't being updated
after single-stepping. This will get you nowhere fast! But it's all
fixed now, and here's how it works...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ qemu-system-moxie -s -S -kernel hello.x&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This tells qemu to load our hello world program, hello.x. The "-s"
option tells it to wait for a connection from GDB on port 1234. The -S
option tells it to freeze on startup, and wait for a "continue" command
from the debugger.&lt;/p&gt;
&lt;p&gt;Now, in a different terminal, fire up moxie-elf-gdb on hello.x and
connect to qemu like so:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(gdb) target remote localhost:1234&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GDB and qemu should be talking now, and the debugger will report that
the sim is waiting on &lt;code&gt;__start&lt;/code&gt;, the entry point to our hello.x ELF
file. Put a breakpoint on &lt;code&gt;main&lt;/code&gt;, and hit 'c' to continue. You should be
debugging as usual now. I normally run moxie-elf-gdb within emacs in
order to get a nice UI, but invoking it from ddd or Eclipse should work
just as well.&lt;/p&gt;
&lt;p&gt;Everything has been committed &lt;a href="http://www.moxielogic.org/wiki/index.php?title=MoxieDev"&gt;MoxieDev&lt;/a&gt;. Now it's time to enjoy this
sunny day!&lt;/p&gt;</summary><category term="gdb"></category><category term="qemu"></category></entry><entry><title>A Tiny Computer</title><link href="http://moxielogic.github.io/blog/a-tiny-computer.html" rel="alternate"></link><published>2009-03-13T14:48:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-13:blog/a-tiny-computer.html</id><summary type="html">&lt;p&gt;&lt;a href="http://lambda-the-ultimate.org/"&gt;Lambda the Ultimate&lt;/a&gt; today posted a interesting blog entry on &lt;a href="http://lambda-the-ultimate.org/node/3232"&gt;A Tiny
Computer&lt;/a&gt;. It refers to 2007 paper by Chuck Thacker at Microsoft
Research describing a tiny 32-bit processor. Appendix A of the paper
includes the entire synthesizeable verilog implementation in just a page
and a half of code! Here's a direct link to the PDF:
&lt;a href="http://www.bottomup.co.nz/mirror/Thacker-A_Tiny_Computer-3.pdf"&gt;http://www.bottomup.co.nz/mirror/Thacker-A_Tiny_Computer-3.pdf&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I plan on using verilog for my initial moxie implementation. I'm told
that it's the clear choice from a tools perspective. There's even a free
software implementation already packaged for &lt;a href="http://fedoraproject.org"&gt;Fedora&lt;/a&gt;: &lt;a href="http://www.icarus.com/eda/verilog"&gt;Icarus
Verilog&lt;/a&gt;. As far as eduction is concerned, I've mainly been using the
two terrific books show below. Do you have any better suggestions? I'd
love to hear them.&lt;/p&gt;
&lt;p&gt;Now, however, I'm still debugging GDB's interaction with qemu. It mostly
involves watching &lt;a href="http://sourceware.org/gdb/current/onlinedocs/gdb_34.html#SEC721"&gt;remote protocol&lt;/a&gt; traffic, looking up the packet
codes, and then trying to understand why the simulator is not behaving
as expected. Good times...&lt;/p&gt;</summary><category term="verilog"></category></entry><entry><title>Progress...</title><link href="http://moxielogic.github.io/blog/progress.html" rel="alternate"></link><published>2009-03-12T20:34:00-04:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-12:blog/progress.html</id><summary type="html">&lt;p&gt;I made some progress on using moxie-elf-gdb with qemu the other day.
Qemu has an integrated gdb stub, so GDB speaks to it via the remote
protocol. It's still not quite there, but getting close. I'm anxious to
get it working, as it's the last step before hacking on the Linux kernel
port.&lt;/p&gt;
&lt;p&gt;I've also tweaked the "ant srpm" target, so it creates clean SRPMs for
binutils, newlib, gcc, gdb and qemu. Well, sort of. When building GCC
from scratch you actually have to build it twice: once to build newlib,
and the second time with the installed newlib. This is easy enough to
handle in MoxieDev where I have a single tree and full control over the
build sequence. It's a little bit weirder in RPM-land because of the
circular dependencies between packages. I was able to bootstrap it on my
system, but it's a hack. I may resort to merging the newlib sources into
the GCC SPRM, and then make newlib a subpackage of gcc. Release
engineering is the suck!&lt;/p&gt;
&lt;p&gt;And, finally, I've merged the latest and greatest trunk revisions of gcc
and src into MoxieDev. Woooo - it all still works! Check out the commit
logs in the &lt;a href="http://moxielogic.org/blog"&gt;blog sidebar&lt;/a&gt;.&lt;/p&gt;</summary><category term="gcc"></category><category term="qemu"></category><category term="releng"></category></entry><entry><title>MoxieDev and the Wiki</title><link href="http://moxielogic.github.io/blog/moxiedev-and-the-wiki.html" rel="alternate"></link><published>2009-03-07T06:22:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-07:blog/moxiedev-and-the-wiki.html</id><summary type="html">&lt;p&gt;Now that the project has been renamed, the mercurial source repository
has also changed from ggxdev to MoxieDev. This repository contains the
entire toolchain, simulators and benchmark programs. You can check the
entire thing out like so...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;hg clone http://mercurial.intuxication.org/hg/moxiedev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I've also created a &lt;a href="http://moxielogic.org/wiki"&gt;wik&lt;/a&gt;&lt;a href="http://moxielogic.org/wiki"&gt;i&lt;/a&gt;, explaining how to check out, build
and use the tools. It's all here: &lt;a href="http://moxielogic.org/wiki"&gt;http://moxielogic.org/wiki&lt;/a&gt;.&lt;/p&gt;</summary></entry><entry><title>Qemu says Hello, World!</title><link href="http://moxielogic.github.io/blog/qemu-says-hello-world.html" rel="alternate"></link><published>2009-03-07T06:22:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-07:blog/qemu-says-hello-world.html</id><summary type="html">&lt;p&gt;Virtually all of the simulation done so far was with the GDB instruction
set simulator. As a basic instruction set simulator, it was limited to
executing instructions found in typical "user level" applications. And,
if you recall, all interaction with the outside world happened through
magic software interrupts that were intercepted by the simulator. I
wrote about this interaction way back here:
&lt;a href="http://spindazzle.org/greenblog/index.php?/archives/107-ggx-Hello-World!.html"&gt;http://spindazzle.org/greenblog/index.php?/archives/107-ggx-Hello-World!.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Instruction set simulators are interesting for one reason: they're easy
to write! It's simple to whip up a sim in the early stages of toolchain
development in order to test your tools. In fact, almost every GCC port
has a corresponding instruction set simulator to test the compiler's
output. On the other hand, the basic instruction set simulator is not
capable of running more interesting software, like operating system
kernels, because they don't simulate any of the ancillary features of a
microprocessor: peripherals, timers, interrupt controllers, MMUs, etc.
This is where system simulators come into play.&lt;/p&gt;
&lt;p&gt;For the moxie toolchain, I've selected the popular &lt;a href="http://qemu.org"&gt;qemu&lt;/a&gt; simulator.
Several months ago I wrote about my start with qemu here:
&lt;a href="http://spindazzle.org/greenblog/index.php?/archives/123-qemu-ggx-softmmu-starts-crawling.html"&gt;http://spindazzle.org/greenblog/index.php?/archives/123-qemu-ggx-softmmu-starts-crawling.html&lt;/a&gt;.
Well, a lot of that work had to be rewritten for the new qemu (version
0.10 was just released last week). Qemu switched from a simple template
compiler to using a real C compiler backend from the &lt;a href="http://bellard.org/tcc"&gt;Tiny C Compiler&lt;/a&gt;
project. The template compiler (dyngen) stitched together fragments of
pre-compiled code at runtime, while the new TCG backend is a proper x86
compiler with simple optimization passes.&lt;/p&gt;
&lt;p&gt;In practice, this wasn't a huge amount of work. The translator still
looks like a huge switch statement where we handle each opcode. For
instance, here's a register-to-register move:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; case 0x02:  /* mov (register-to-register) */
   {
     int dest = (opcode &amp;gt;&amp;gt; 4) &amp;amp; 0xf;
     int src = opcode &amp;amp; 0xf;
     tcg_gen_mov_i32(REG(dest), REG(src));
   }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;tcg_gen_mov_i32&lt;/code&gt; generates the intermediate code to move the value
between registers.&lt;/p&gt;
&lt;p&gt;Once I had implemented support for enough instructions, I was able to
run a trivial Hello World program straight through:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cat hello.c
&lt;span class="c"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

int main&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  puts &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; 0&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;moxie-elf-gcc -o hello.x hello.c
&lt;span class="nv"&gt;$ &lt;/span&gt;qemu-system-moxie -nographic -kernel hello.x
qemu: fatal: Trying to execute code outside RAM or ROM at 0x00000000

&lt;span class="nv"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000
&lt;span class="nv"&gt;$fp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$sp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x0000000c &lt;span class="nv"&gt;$r0&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000001 &lt;span class="nv"&gt;$r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x000055c4
&lt;span class="nv"&gt;$r2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r3&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r4&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x001ffff4 &lt;span class="nv"&gt;$r5&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000
&lt;span class="nv"&gt;$r6&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r7&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r8&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r9&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000
&lt;span class="nv"&gt;$r10&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r11&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r12&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r13&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0xfffffff4
Aborted
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Oops. Two problems: no "Hello, World" output and the fatal error. The
fatal error is simple to explain. The moxie qemu port defines a virtual
hardware platform, with physical memory mapped way up at 0x8000000.
Somehow the simulator is trying to execute code outside of our physical
memory range. The reason turns out to be simple. Unlike our simple
instruction set simulator, system simulators like qemu don't expect to
run programs that "exit". They're designed to run operating systems that
start running and never finish. If you look carefully above you'll see
that I'm asking qemu to run a "kernel" called hello.x. Well, hello.x is
actually just a regular user program that exits. In this case, the
processor is running off of the end of the __init entry point and
pulling an uninitialized return address off of the stack, sending us off
to execute code at 0x00000000.&lt;/p&gt;
&lt;p&gt;But where is "Hello, World"? We're still linking in libgloss, which is
trying to "_write" output with our special software interrupt. That's
not going to work here. We don't want to implement magic IO in a system
simulator. We want to simulate real IO! One of the beautiful things
about qemu is that it comes with a wealth of simulated peripherals that
you can hook up to your processor. So, for now, let's just send all
output to a simulated serial port. Qemu makes this very simple. In the
module that defines our hardware platform, we just add:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    /* A single 16450 sits at offset 0x3f8.  */
    if (serial_hds[0])
      serial_mm_init(0x3f8, 0, env-&amp;gt;irq[4], 8000000/16, serial_hds[0], 1);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we just have to override the _write in libgloss to write to the
16450 UART which has been mapped to memory at 0x3f8. Qemu's default
setting has all serial port output going to the console. So now....&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cat hello.c
&lt;span class="c"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

int _write &lt;span class="o"&gt;(&lt;/span&gt;int fd, char *buf, int len&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  int &lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 0&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;i &amp;lt; len&lt;span class="o"&gt;)&lt;/span&gt;
    *&lt;span class="o"&gt;(&lt;/span&gt;char *&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;0x3f8&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; buf&lt;span class="o"&gt;[&lt;/span&gt;i++&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; len&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

int main&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  puts &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; 0&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;moxie-elf-gcc -o hello.x hello.c
&lt;span class="nv"&gt;$ &lt;/span&gt;./qemu-system-moxie -nographic -kernel hello.x
Hello World!qemu: fatal: Trying to execute code outside RAM or ROM at 0x00000000

&lt;span class="nv"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000
&lt;span class="nv"&gt;$fp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$sp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x0000000c &lt;span class="nv"&gt;$r0&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000001 &lt;span class="nv"&gt;$r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x000055c4
&lt;span class="nv"&gt;$r2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r3&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r4&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x001ffff4 &lt;span class="nv"&gt;$r5&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000
&lt;span class="nv"&gt;$r6&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r7&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r8&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r9&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000
&lt;span class="nv"&gt;$r10&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r11&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r12&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00000000 &lt;span class="nv"&gt;$r13&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0xfffffff4
Aborted
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Very nice!&lt;/p&gt;</summary><category term="qemu"></category></entry><entry><title>Moxie: the ggx reboot</title><link href="http://moxielogic.github.io/blog/moxie-the-ggx-reboot.html" rel="alternate"></link><published>2009-03-07T05:23:00-05:00</published><author><name>green</name></author><id>tag:moxielogic.github.io,2009-03-07:blog/moxie-the-ggx-reboot.html</id><summary type="html">&lt;p&gt;Hola Amigos!  Several months ago I experimented with a new ISA design
called &lt;a href="http://spindazzle.org/ggx"&gt;ggx&lt;/a&gt;. I blogged about the co-evolution of the ISA and tools,
and it was fun.&lt;/p&gt;
&lt;p&gt;Now, after a short break, I'm ready to resume hacking.&lt;/p&gt;
&lt;p&gt;I'm also ready to put a stake in the ground as far as goals are
concerned. My original goal with this effort was to bring up a toolchain
for a new ISA from scratch. &lt;a href="http://mercurial.intuxication.org/hg/ggxdev"&gt;Mission Accomplished&lt;/a&gt;. The next steps?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boot the Linux kernel on a &lt;a href="http://en.wikipedia.org/wiki/Qemu"&gt;qemu&lt;/a&gt; port&lt;/li&gt;
&lt;li&gt;Produce a synthesizable &lt;a href="http://en.wikipedia.org/wiki/Verilog"&gt;verilog&lt;/a&gt; implementation running on
    &lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA&lt;/a&gt; hardware.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope this will be an interesting journey. Please &lt;a href="http://feeds2.feedburner.com/moxielogic/HHXH"&gt;subscribe to this
new blog&lt;/a&gt; and make heavy use of the comments.&lt;/p&gt;
&lt;p&gt;I've also decided to rename the processor. The ggx processor is now the
&lt;strong&gt;moxie&lt;/strong&gt; processor!&lt;/p&gt;</summary></entry></feed>